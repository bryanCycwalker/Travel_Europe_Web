<!DOCTYPE html>
<html lang="zh-Hant">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>

<title>Bryan's Travel Map | Interactive Europe Map & 歐洲自由行足跡</title>

<meta name="description" content="Explore Europe with Bryan! An interactive 3D travel map tracking journeys from 2023 to 2026. 跟著 Bryan 探索歐洲！透過 3D 互動地圖完整記錄自由行足跡、跨國行程攻略與城市私房景點推薦。">

<meta name="keywords" content="Europe travel, 歐洲旅遊, interactive travel map, 互動旅遊地圖, backpacking Europe, 歐洲自由行, Europe itinerary, 行程規劃, Europe road trip, 歐洲跨國, Bryan Travel Map">

<meta property="og:title" content="Bryan's Travel Map | Interactive Europe Map & 歐洲自由行足跡">
<meta property="og:description" content="An interactive 3D travel map tracking journeys and sharing travel guides. 透過 3D 飛梭地圖完整記錄歐洲自由行足跡與私房推薦。">
<meta property="og:type" content="website">
<meta property="og:url" content="https://你的網站網址.com">
<meta property="og:image" content="https://你的網站網址.com/preview-image.jpg"> 

</head>
<style>
/* --- 1. Reset & Base --- */
html, body { margin:0; padding:0; height:100%; overflow:hidden; font-family:Arial,sans-serif; background: #000; }
a { text-decoration: none; color: inherit; }

/* --- 2. Layout & Map Container --- */
#bgImageContainer { 
    position:absolute; top:0; left:0; width:100%; height:100%; overflow:hidden; 
    opacity:0; z-index: 1; will-change: opacity; 
    pointer-events: none; 
}
#bgImageContainer svg { position:absolute; top:0; left:0; will-change: transform, width, height; }

/* --- 3. Warp Speed 3D Layers --- */
#introPhotos {
    position: fixed; top: 0; left: 0; width: 100vw; height: 100vh;
    perspective: 800px; z-index: 5;
    overflow: hidden; pointer-events: none;
}
.intro-photo {
    position: absolute; left: 50%; top: 50%;
    transform-origin: center center;
    box-shadow: 0 10px 40px rgba(0,0,0,1);
    border-radius: 6px; width: 280px; object-fit: cover;
    will-change: transform, opacity;
}

#warpMask {
    position: fixed; top: 0; left: 0; width: 100vw; height: 100vh;
    background: rgba(0,0,0,0.65); 
    z-index: 10; pointer-events: none;
    transition: opacity 0.5s ease;
}

#introTitle {
    position: fixed; top: 0; left: 0; width: 100vw; height: 100vh;
    perspective: 800px; z-index: 20; 
    pointer-events: none;
}
.intro-title-content {
    position: absolute; left: 50%; top: 50%;
    color: white; text-align: center;
    will-change: transform, opacity;
}
.intro-title-content h1 { font-size: 3.5em; margin: 0; text-shadow: 0 4px 20px rgba(0,0,0,0.8); white-space: nowrap; }
.intro-title-content h2 { font-size: 1.5em; margin: 10px 0 0; font-weight: normal; }

/* --- 4. Left Panel --- */
#leftPanel {
  position:absolute; top:0; left:-33.33%; width:33.33%; height:100%;
  background:#3f3f3f; color:#fff; display:flex; flex-direction:column;
  align-items:center; padding-top:0; overflow:hidden; opacity:0; z-index:30;
}
#panelContent { width: 100%; height: 100%; display: flex; flex-direction: column; align-items: center; position: relative; transition: transform 0.4s ease, opacity 0.4s ease; }
#leftPanel h1 { font-size:1.6em; font-weight:normal; text-align:center; margin: 0; padding: 40px 0 20px; width: 100%; flex-shrink: 0; z-index: 25; background-color: #3f3f3f; position: relative; box-shadow: 0 2px 10px rgba(0,0,0,0.2); }
#timelineScrollArea { flex-grow: 1; width: 100%; overflow-y: auto; overflow-x: hidden; scroll-behavior: smooth; scrollbar-width: none; -ms-overflow-style: none; position: relative; z-index: 10; }
#timelineScrollArea::-webkit-scrollbar { display: none; }
#timeline { position:relative; width:4px; background: rgba(255,255,255,0.3); margin:0 auto; padding-top: 0; padding-bottom: 0; min-height: 100%; display: flex; flex-direction: column; align-items: center; }
#timeline::before { content: ''; display: block; width: 100%; height: 45vh; flex-shrink: 0; }
#timeline::after { content: ''; display: block; width: 100%; height: 45vh; flex-shrink: 0; }
#leftPanel .fadeMask { position:absolute; top:80px; left:0; width:100%; height:80px; pointer-events:none; background: linear-gradient(to bottom, #3f3f3f 10%, transparent 100%); z-index:20; }

/* --- 5. Timeline Events --- */
.timeline-event { position: relative; width: 100%; cursor: pointer; padding: 6px 0; margin-bottom: 100px; transition: opacity 0.2s ease, transform 0.2s ease; opacity: 0.3; display: flex; justify-content: center; align-items: center; flex-shrink: 0; }
.timeline-event:last-child { margin-bottom: 0; }
.timeline-event .tick { width:10px; height:2px; background:rgba(255,255,255,0.8); position:absolute; left: 50%; margin-left: -5px; z-index:2; transition: all 0.2s ease; }
.timeline-event .date { position:absolute; right: 50%; margin-right: 20px; width:100px; text-align:right; font-size:12px; color:#ddd; z-index:2; white-space: normal; line-height: 1.4; }
.timeline-event .text { position:absolute; left: 50%; margin-left: 20px; font-size:14px; color:#fff; z-index:2; white-space:nowrap; transition: color 0.2s; }
.timeline-event:hover .text { color: #ffd700; font-weight: bold; }
.timeline-event.active-highlight { opacity: 1 !important; transform: scale(1.1); }
.timeline-event.active-highlight .text { color: #ffd700; font-weight: bold; font-size: 1.25em; text-shadow: 0 0 8px rgba(255, 215, 0, 0.6); }
.timeline-event.active-highlight .tick { background: #ffd700; width: 18px; box-shadow: 0 0 8px rgba(255, 215, 0, 0.8); margin-left: -9px; }
.timeline-event.active-highlight .date { color: #fff; font-weight: bold; }
.timeline-story-link { margin-top: 40px; padding-bottom: 60px; display: flex; justify-content: center; width: 100%; }
#moreStoryBtn { padding: 10px 25px; background: #b16837; color: white; border-radius: 20px; cursor: pointer; font-size: 14px; font-weight: bold; transition: all 0.3s ease; border: 1px solid rgba(255,255,255,0.2); box-shadow: 0 4px 15px rgba(0,0,0,0.3); opacity: 1; }
#moreStoryBtn:hover { background: #d4824b; transform: scale(1.05); }

/* --- 6. Controls & Overlays --- */
.overlay-bottom { position: fixed; left: 0; bottom: 0; width: 100vw; height: 6vh; background: rgba(0,0,0,0.7); display: flex; justify-content: center; align-items: center; z-index: 45; transform: translateY(100%); transition: transform 0.4s ease; }
.overlay-bottom .inner { display:flex; align-items:center; gap:12px; font-size:16px; color:#fff; }
.overlay-bottom a { padding:4px 6px; cursor:pointer; }
#backButton { position: fixed; top: 20px; left: -80px; width: 60px; height: 40px; background: rgba(0,0,0,0.6); color: white; display: flex; justify-content: center; align-items: center; border-radius: 8px; cursor: pointer; z-index: 100; transition: left 0.5s ease; }
#eventBackButton { position: fixed; bottom: 20px; right: 20px; width: 100px; height: 40px; background: rgba(0,0,0,0.6); color: white; display: flex; justify-content: center; align-items: center; border-radius: 8px; cursor: pointer; z-index: 100; opacity: 0; transition: opacity 0.5s ease; pointer-events: none; }
#eventBackButton.active { opacity: 1; pointer-events: auto; }

/* --- 7. Tooltips & Rich Info Box --- */
#countryLabel { position:absolute; pointer-events:none; background:transparent; color: rgb(139, 84, 45); padding:0; font-size: 24px; font-weight: bold; white-space:nowrap; transform: translate(-50%, -50%) scale(1); transform-origin: center center; opacity:0; transition: opacity 0.4s ease, transform 0.6s cubic-bezier(0.175, 0.885, 0.32, 1.275); z-index:155; text-shadow: 1px 1px 0px rgba(255,255,255,0.4); }
#cityLabel { position: absolute; pointer-events: none; background: rgba(0, 0, 0, 0.8); color: #ededed; padding: 4px 8px; border-radius: 4px; font-size: 14px; font-weight: bold; white-space: nowrap; transform: translate(-50%, -120%); opacity: 0; transition: opacity 0.2s ease; z-index: 160; border: 1px solid rgba(255, 255, 255, 0.2); box-shadow: 0 2px 6px rgba(0,0,0,0.2); }
#infoOverlay { display:none; position:fixed; top:0; left:0; width:100vw; height:100vh; background:rgba(0,0,0,0.6); justify-content:center; align-items:center; z-index:300; backdrop-filter: blur(2px); }
#infoBox { background: #fff; color: #333; width: 90%; max-width: 380px; border-radius: 12px; overflow: hidden; box-shadow: 0 10px 25px rgba(0,0,0,0.5); display: flex; flex-direction: column; max-height: 80vh; }
.info-content { padding: 20px; display: flex; flex-direction: column; gap: 10px; overflow-y: auto; }
.info-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px; }
.info-city { font-size: 1.8em; font-weight: bold; color: #222; margin: 0; }
.explore-btn { padding: 4px 12px; background: #222; color: #fff; border-radius: 15px; font-size: 12px; cursor: pointer; transition: background 0.2s; border: none; white-space: nowrap; margin-left: 10px; }
.explore-btn:hover { background: #b16837; }
.visit-list { display: flex; flex-direction: column; gap: 12px; margin-top: 10px; }
.visit-item { background: #f9f9f9; border: 1px solid #eee; border-radius: 8px; padding: 12px; transition: transform 0.2s, box-shadow 0.2s; cursor: default; }
.visit-item.clickable-box { cursor: pointer; border-color: #ddd; }
.visit-item.clickable-box:hover { transform: translateY(-2px); box-shadow: 0 4px 8px rgba(0,0,0,0.1); border-color: #b16837; }
.visit-header { display: flex; justify-content: flex-start; align-items: center; margin-bottom: 6px; }
.visit-date-badge { background: #eef3ff; color: #b16837; font-weight: bold; font-size: 0.85em; padding: 4px 8px; border-radius: 4px; border: 1px solid #ddd; transition: all 0.2s; }
.visit-main-text { font-size: 1.1em; font-weight: bold; color: #333; margin-bottom: 4px; }
.visit-sub-text { font-size: 0.95em; color: #666; line-height: 1.4; }
.visit-item.stay-item { background: #333 !important; border-color: #444; color: #f4f4f4; }
.visit-item.stay-item .visit-date-badge { background: #b16837; color: #fff; border: none; }
.visit-item.stay-item .visit-sub-text { color: #ccc; }

/* --- 8. Map Elements --- */
.country-highlight { fill: rgb(203, 150, 97) !important; transition: fill .25s ease; }
.country-focus { fill: rgb(237, 186, 123) !important; }
.rightPoint { position:absolute; width:14px; height:14px; background:#b16837; border-radius:50%; pointer-events:none; opacity:0; transition:opacity .25s ease; z-index:200 !important; cursor: pointer; }
.rightPoint.star { width: 20px; height: 20px; background: #9889bd; clip-path: polygon(50% 0%, 61% 35%, 98% 35%, 68% 57%, 79% 91%, 50% 70%, 21% 91%, 32% 57%, 2% 35%, 39% 35%); z-index: 200 !important; }
.rightPoint.star-highlight { background-color: rgb(139, 42, 121) !important; }
.rightPoint.map-marker-highlight, .star.map-marker-highlight { background-color: #ffd700 !important; transform: scale(1.6) !important; box-shadow: 0 0 15px rgba(255, 215, 0, 0.8); z-index: 250 !important; border: 2px solid #fff; transition: all 0.2s ease; }
.event-route-line { display: none !important; }

@media (max-width:480px){ .intro-title-content h1 { font-size:2em; } .overlay-bottom .inner { gap:8px; font-size:14px; } #infoBox { width: 95%; } }
</style>
</head>
<body>

<div id="bgImageContainer"></div>

<div id="introPhotos"></div>
<div id="warpMask"></div>
<div id="introTitle">
    <div class="intro-title-content" data-orig-z="0">
        <h1>Tracing Europe with Bryan</h1>
        <h2>2023.09.17 - 2026.03.31</h2>
    </div>
</div>

<div id="leftPanel">
  <div id="panelContent">
      <h1>Timeline</h1>
      <div id="timelineScrollArea">
          <div id="timeline"></div>
      </div>
  </div>
  <div class="fadeMask"></div>
</div>

<div id="countryLabel"></div>
<div id="cityLabel"></div>

<div id="housePoint1" class="rightPoint star"></div>
<div id="housePoint2" class="rightPoint star"></div>
<div id="housePoint3" class="rightPoint star"></div>
<div id="housePoint4" class="rightPoint star"></div>
<div id="dePoint1" class="rightPoint"></div>
<div id="dePoint2" class="rightPoint"></div>
<div id="dePoint3" class="rightPoint"></div>
<div id="dePoint4" class="rightPoint"></div>
<div id="dePoint5" class="rightPoint"></div>
<div id="dePoint6" class="rightPoint"></div>
<div id="atPoint1" class="rightPoint"></div>
<div id="frtrip1" class="rightPoint"></div>
<div id="frtrip2" class="rightPoint"></div>
<div id="bePoint1" class="rightPoint"></div>
<div id="bePoint2" class="rightPoint"></div>
<div id="bePoint3" class="rightPoint"></div>
<div id="bePoint4" class="rightPoint"></div>
<div id="bePoint5" class="rightPoint"></div>
<div id="plPoint1" class="rightPoint"></div>
<div id="plPoint2" class="rightPoint"></div>
<div id="plPoint3" class="rightPoint"></div>
<div id="plPoint4" class="rightPoint"></div>
<div id="plPoint5" class="rightPoint"></div>
<div id="betrip1" class="rightPoint"></div>
<div id="betrip2" class="rightPoint"></div>
<div id="betrip3" class="rightPoint"></div>
<div id="betrip4" class="rightPoint"></div>
<div id="betrip5" class="rightPoint"></div>

<div id="overlayBottom" class="overlay-bottom" aria-hidden="true">
  <div class="inner">
    <a id="aboutLink">About</a> <span class="sep">|</span>
    <span class="label">BRYAN TRAVEL MAP</span> <span class="sep">|</span>
    <a id="contactLink">Contact</a>
  </div>
</div>

<div id="backButton">&#8592;</div>
<div id="eventBackButton">&#8592; Back</div>

<div id="infoOverlay">
  <div id="infoBox"></div>
</div>

<script src="data.js"></script>
<script>
const CONFIG = {
    scrollFactor: 0.002, friction: 0.85, 
    svgUrl: 'https://raw.githubusercontent.com/bryanCycwalker/Travel_Web_svg/refs/heads/main/Europe_map_new_202602.svg'
};

const state = {
    // 【修改】將總深度大幅提升，創造遙遠距離感
    WARP_DEPTH: 25000, 
    scrollDepth: 0, velocity: 0, bottomAccum: 0, progress: 0,
    countryFocused: false, focusedCountryId: null,
    eventFocused: false, focusedEvent: null,
    savedSVGState: null, savedLeftPanel: null,
    hoverEl: null, stopoverActive: false, animatingReturn: false,
    returnToCountryMode: false 
};

const DATA = window.DATA;

const dom = {
    bgContainer: document.getElementById('bgImageContainer'),
    leftPanel: document.getElementById('leftPanel'),
    panelContent: document.getElementById('panelContent'),
    scrollArea: document.getElementById('timelineScrollArea'),
    timeline: document.getElementById('timeline'),
    countryLabel: document.getElementById('countryLabel'),
    cityLabel: document.getElementById('cityLabel'),
    overlayBottom: document.getElementById('overlayBottom'),
    backBtn: document.getElementById('backButton'),
    eventBackBtn: document.getElementById('eventBackButton'),
    infoOverlay: document.getElementById('infoOverlay'),
    infoBox: document.getElementById('infoBox'),
    warpMask: document.getElementById('warpMask'),
    markers: new Map(),
    svg: null
};

document.querySelectorAll('.rightPoint').forEach(el => dom.markers.set(el.id, el));

function tween(from, to, duration, onUpdate, onComplete) {
    const startTime = performance.now();
    function loop(time) {
        const t = Math.min(1, (time - startTime) / duration);
        const eased = t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t; 
        const current = from + (to - from) * eased;
        onUpdate(current, eased);
        if (t < 1) requestAnimationFrame(loop);
        else if (onComplete) onComplete();
    }
    requestAnimationFrame(loop);
}

function transitionPanelContent(direction, updateCallback) {
    const el = dom.panelContent;
    const offset = direction === 'forward' ? -50 : 50;
    el.style.transform = `translateX(${offset}px)`; el.style.opacity = '0';
    setTimeout(() => {
        updateCallback();
        el.style.transition = 'none';
        const startPos = direction === 'forward' ? 50 : -50;
        el.style.transform = `translateX(${startPos}px)`;
        void el.offsetWidth;
        el.style.transition = 'transform 0.4s ease, opacity 0.4s ease';
        el.style.transform = 'translateX(0)'; el.style.opacity = '1';
    }, 300);
}

function getCountryId(el) { if (!el) return null; const validKeys = Object.keys(DATA.markers); const clean = (id) => id ? id.trim().toLowerCase() : null; let currentId = clean(el.id); if (validKeys.includes(currentId)) return currentId; const parent = el.closest('g'); if (parent) { currentId = clean(parent.id); if (validKeys.includes(currentId)) return currentId; } return clean(el.id) || (parent ? clean(parent.id) : null); }
function getGenericOwner(id) { if (DATA.markers.home.some(m => m.id === id)) return 'home'; for (let key of Object.keys(DATA.markers)) { if (key === 'home') continue; if (DATA.markers[key].some(m => m.id === id)) return key; } return null; }
function findMarkerBaseData(id) {
    let found = DATA.markers.home.find(m => m.id === id); if (found) return found;
    for (let key of Object.keys(DATA.markers)) { if (key === 'home') continue; found = DATA.markers[key].find(m => m.id === id); if (found) return found; }
    for (let ev of DATA.events) { if (ev.eventMarkers) { found = ev.eventMarkers.find(m => m.id === id); if (found) return found; } }
    return null;
}

function showRichInfo(id) {
    dom.countryLabel.style.opacity = 0;
    dom.cityLabel.style.opacity = 0;

    const baseData = findMarkerBaseData(id);
    const cityName = baseData?.city || "Unknown City";

    let cId = baseData?.country || getGenericOwner(id);
    if (!cId) {
        if (id.startsWith('de') || id === 'housePoint1') cId = 'de';
        else if (id.startsWith('be')) cId = 'be';
        else if (id.startsWith('fr')) cId = 'fr';
    }

    const targetPage = { 'de': 'Germany.html', 'be': 'Belgium.html', 'fr': 'France.html' }[cId] || 'Germany.html';

    let listHTML = "";
    if (state.eventFocused && state.focusedEvent) {
        let cityMarkers = (state.focusedEvent.eventMarkers || []).filter(m => m.id === id);
        let processedGroups = [];

        cityMarkers.forEach(curr => {
            let last = processedGroups[processedGroups.length - 1];
            if (last && curr.stay && last.stay === curr.stay) {
                if ((new Date(curr.date) - new Date(last.endDate || last.date)) / 86400000 <= 1) {
                    last.endDate = curr.date; 
                    return; 
                }
            }
            processedGroups.push({ ...curr });
        });

        processedGroups.forEach(m => {
            let dateDisplay = m.endDate && m.endDate !== m.date ? `${m.date} ~ ${m.endDate}` : m.date;
            listHTML += `
                <div class="visit-item ${m.stay ? "stay-item" : ""}">
                    <div class="visit-header"><span class="visit-date-badge">${dateDisplay}</span></div>
                    <div class="visit-sub-text">${m.stay || m.desc || ""}</div>
                </div>`;
        });
    } else {
        let tripMap = new Map();
        DATA.events.forEach((ev, idx) => {
            let dates = [];
            if (ev.eventMarkers) ev.eventMarkers.filter(m => m.id === id).forEach(m => dates.push(m.date || ev.date));
            if (dates.length === 0 && ev.markerIds && ev.markerIds.includes(id)) dates.push(ev.date);
            if (dates.length > 0) {
                dates.sort();
                tripMap.set(idx, { name: ev.text, dateRange: dates.length > 1 ? `${dates[0]} ~ ${dates[dates.length - 1]}` : dates[0], idx: idx });
            }
        });
        tripMap.forEach(info => {
            listHTML += `
                <div class="visit-item clickable-box" onclick="window.handleDateTagClick(${info.idx}, '${id}')">
                    <div class="visit-header"><span class="visit-date-badge clickable-link">${info.dateRange}</span></div>
                    <div class="visit-main-text">${info.name}</div>
                </div>`;
        });
    }

    // 【終極防呆：圖片路徑判斷與印出】
    let imagePath = "";
    if (baseData && baseData.img) {
        if (baseData.img.includes("/")) {
            imagePath = baseData.img; // 如果裡面已經有斜線，代表寫了完整路徑
        } else {
            imagePath = `Photos/${cityName}/${baseData.img}`; // 只有檔名，自動補齊
        }
        console.log(`[Debug] 城市 ${cityName} 嘗試載入圖片路徑:`, imagePath);
    }
    const imgHTML = imagePath ? `<img src="${imagePath}" alt="${cityName}">` : '';

    dom.infoBox.innerHTML = `
        ${imgHTML}
        <div class="info-content">
            <div class="info-header">
                <h3 class="info-city">${cityName}</h3>
                <button class="explore-btn" onclick="window.location.href='${targetPage}?city=${encodeURIComponent(cityName)}'">Explore More</button>
            </div>
            <div class="visit-list">${listHTML}</div>
        </div>`;
    dom.infoOverlay.style.display = "flex";
}

window.handleDateTagClick = function(eventIndex, highlightMarkerId) { 
    if (eventIndex < 0) return;
    const targetEvent = DATA.events[eventIndex];
    if (!targetEvent) return;
    dom.infoOverlay.style.display = "none";
    if (state.countryFocused) {
        state.returnToCountryMode = true;
        state.savedSVGState = { w: parseFloat(dom.svg.style.width), h: parseFloat(dom.svg.style.height), t: dom.svg.style.transform };
    } else state.returnToCountryMode = false;
    focusOnEvent(targetEvent, highlightMarkerId); 
}

dom.infoBox.addEventListener('click', (e) => e.stopPropagation());
dom.infoOverlay.addEventListener('click', () => { 
    dom.infoOverlay.style.display = "none"; 
    if (state.countryFocused) dom.countryLabel.style.opacity = 1;
});

async function initMap() {
    try {
        const resp = await fetch(CONFIG.svgUrl);
        dom.bgContainer.innerHTML = await resp.text();
        dom.svg = dom.bgContainer.querySelector('svg');
        const routeG = document.createElementNS("http://www.w3.org/2000/svg", "g");
        routeG.id = "routeLayer";
        dom.svg.appendChild(routeG); 
        if (!dom.svg.viewBox.baseVal.width) dom.svg.setAttribute('viewBox', `0 0 ${dom.svg.getAttribute('width') || 2000} ${dom.svg.getAttribute('height') || 1200}`);
        dom.svg.style.width = '100%'; dom.svg.style.height = '100%';
        setupMapInteractions();
        startAnimationLoop();
    } catch (e) { console.error("SVG Load Failed:", e); }
}

function setupMapInteractions() {
    dom.svg.querySelectorAll('path, polygon, rect, circle').forEach(el => {
        if (el.id && el.id.toLowerCase().includes("path")) return;
        el.style.cursor = "pointer";
        el.addEventListener("mouseenter", () => {
            if (state.eventFocused || state.progress < 0.1) return;
            if (state.countryFocused && el.tagName !== 'circle') return; 
            state.hoverEl = el;
            const g = el.closest('g') || el;
            g.classList.add('country-highlight');
            g.querySelectorAll('*').forEach(c => c.classList.add('country-highlight'));
            let name = g.querySelector('title')?.textContent || g.id || el.id;
            if (name) updateTooltip(name, el, true);
            updateAllMarkers(getCountryId(el)); 
        });
        el.addEventListener("mouseleave", () => {
            if (state.countryFocused || state.eventFocused) return;
            state.hoverEl = null; clearMapHover(); dom.countryLabel.style.opacity = 0; updateAllMarkers(); 
        });
        el.addEventListener("click", (e) => {
            e.stopPropagation();
            if (!state.eventFocused && !state.countryFocused) focusOnCountry(el);
        });
    });
}

function clearMapHover() { if(dom.svg) dom.svg.querySelectorAll('.country-highlight').forEach(el => el.classList.remove('country-highlight')); }

function updateTooltip(text, targetEl, isSVGElement = false) {
    if (!text || !dom.svg || !targetEl || (dom.countryLabel.dataset.locked === "true" && !isSVGElement)) return;
    dom.countryLabel.textContent = text; dom.countryLabel.style.opacity = 1;
    let x, y;
    if (isSVGElement) {
        const bbox = targetEl.getBBox(), pt = dom.svg.createSVGPoint(); 
        pt.x = bbox.x + bbox.width/2; pt.y = bbox.y + bbox.height/2;
        const screen = pt.matrixTransform(dom.svg.getScreenCTM()); x = screen.x; y = screen.y;
    } else {
        const rect = targetEl.getBoundingClientRect(); x = rect.left + rect.width/2; y = rect.top - 5;
    }
    dom.countryLabel.style.left = `${x}px`; dom.countryLabel.style.top = `${y}px`;
    dom.countryLabel.style.transform = dom.countryLabel.dataset.locked === "true" ? "translate(-50%, -50%) scale(2)" : "translate(-50%, -50%) scale(1)";
}

function updateCityTooltip(text, targetEl) {
    if (!text) { dom.cityLabel.style.opacity = 0; return; }
    dom.cityLabel.textContent = text;
    const rect = targetEl.getBoundingClientRect();
    dom.cityLabel.style.left = `${rect.left + rect.width / 2}px`;
    dom.cityLabel.style.top = `${rect.top}px`;
    dom.cityLabel.style.opacity = 1;
}

function updateAllMarkers(hoverCountryId = null) {
    if (!dom.svg) return;
    
    // 若退回飛梭階段，星星再度消失、並隱藏所有標籤
    if (state.scrollDepth <= state.WARP_DEPTH) {
        dom.markers.forEach(el => {
            el.style.opacity = 0;
            el.style.pointerEvents = "none";
        });
        dom.countryLabel.style.opacity = 0;
        dom.cityLabel.style.opacity = 0;
        return;
    }

    const ctm = dom.svg.getScreenCTM();
    const activeCountry = hoverCountryId || state.focusedCountryId;
    if (state.countryFocused && dom.countryLabel.dataset.locked === "true") {
        const countryEl = document.querySelector('.country-focus');
        if (countryEl) updateTooltip(dom.countryLabel.textContent, countryEl, true);
    }
    const getScreenPos = (x, y) => { const pt = dom.svg.createSVGPoint(); pt.x = x; pt.y = y; return pt.matrixTransform(ctm); };
    
    dom.markers.forEach((el, id) => {
        let isVisible = false, targetX = 0, targetY = 0;
        if (state.eventFocused && state.focusedEvent) {
            if ((state.focusedEvent.markerIds || []).includes(id)) {
                isVisible = true; const evM = (state.focusedEvent.eventMarkers || []).find(m => m.id === id);
                if (evM && evM.x !== undefined) { targetX = evM.x; targetY = evM.y; } else { const base = findMarkerBaseData(id); if (base) { targetX = base.x; targetY = base.y; } }
            }
        } else if (DATA.markers.home.some(m => m.id === id)) { isVisible = true; const m = DATA.markers.home.find(x => x.id === id); targetX = m.x; targetY = m.y; }
        else if (activeCountry) {
            const genericOwner = getGenericOwner(id);
            if (genericOwner === activeCountry) { isVisible = true; const m = DATA.markers[activeCountry].find(x => x.id === id); targetX = m.x; targetY = m.y; }
            if (!isVisible) {
                for (let ev of DATA.events) {
                    if (ev.countryCandidates && ev.countryCandidates.includes(activeCountry)) {
                        const evM = ev.eventMarkers ? ev.eventMarkers.find(m => m.id === id) : null, inList = ev.markerIds ? ev.markerIds.includes(id) : false;
                        if (evM || inList) {
                            if (evM && evM.country && evM.country !== activeCountry) continue;
                            if (genericOwner && genericOwner !== activeCountry) continue;
                            isVisible = true;
                            if (evM && evM.x !== undefined) { targetX = evM.x; targetY = evM.y; } else { const base = findMarkerBaseData(id); if (base) { targetX = base.x; targetY = base.y; } }
                            break;
                        }
                    }
                }
            }
        }
        if (isVisible) {
            if (targetX !== undefined) {
                const screen = getScreenPos(targetX, targetY);
                el.style.left = `${screen.x - (el.classList.contains('star') ? 10 : 7)}px`;
                el.style.top = `${screen.y - (el.classList.contains('star') ? 10 : 7)}px`;
            }
            el.style.opacity = 1; el.style.pointerEvents = "auto";
        } else { el.style.opacity = 0; el.style.pointerEvents = "none"; }
    });
}

function focusOnCountry(el) {
    state.countryFocused = true; state.focusedCountryId = getCountryId(el);
    const g = el.closest('g') || el;
    updateTooltip(g.querySelector('title')?.textContent || g.id || el.id, el, true);
    dom.countryLabel.dataset.locked = "true";
    dom.countryLabel.style.transform = "translate(-50%, -50%) scale(2)"; 
    tween(0, -33.33, 600, (val) => { dom.leftPanel.style.left = `${val}%`; });
    dom.backBtn.style.left = '20px'; 
    dom.svg.querySelectorAll('.country-focus').forEach(e => e.classList.remove('country-focus'));
    g.classList.add('country-focus'); g.querySelectorAll('*').forEach(e => e.classList.add('country-focus'));
    updateAllMarkers(state.focusedCountryId);
    const bbox = el.getBBox(), padding = 5;
    animateSVGView(bbox.x + bbox.width/2, bbox.y + bbox.height/2, bbox.width + padding*2, bbox.height + padding*2);
    dom.overlayBottom.style.transform = 'translateY(100%)';
}

function returnFromCountryFocus() {
    dom.svg.querySelectorAll('.country-focus').forEach(e => e.classList.remove('country-focus'));
    dom.backBtn.style.left = '-80px'; dom.leftPanel.querySelector('h1').textContent = "Timeline";
    delete dom.countryLabel.dataset.locked;
    dom.countryLabel.style.opacity = 0; dom.countryLabel.style.transform = "translate(-50%, -50%) scale(1)"; 
    buildTimeline();
    tween(-33.33, 0, 600, (val) => { dom.leftPanel.style.left = `${val}%`; });
    animateBackToMainView(() => { state.countryFocused = false; state.focusedCountryId = null; state.velocity = 0; state.returnToCountryMode = false; updateAllMarkers(null); });
}

function focusOnEvent(ev, highlightMarkerId = null) { 
    state.eventFocused = true; state.focusedEvent = ev;
    if (!state.returnToCountryMode) {
        state.savedLeftPanel = { title: dom.leftPanel.querySelector('h1').textContent, html: dom.timeline.innerHTML };
        state.savedSVGState = { w: parseFloat(dom.svg.style.width), h: parseFloat(dom.svg.style.height), t: dom.svg.style.transform };
        transitionPanelContent('forward', () => updateTimelineForEvent(ev, highlightMarkerId));
    } else {
        dom.backBtn.style.left = '-80px'; tween(-33.33, 0, 600, (val) => { dom.leftPanel.style.left = `${val}%`; dom.leftPanel.style.opacity = 1; });
        updateTimelineForEvent(ev, highlightMarkerId);
    }
    let minX=Infinity, maxX=-Infinity, minY=Infinity, maxY=-Infinity; const allPoints = [];
    if(ev.eventMarkers) allPoints.push(...ev.eventMarkers);
    if(ev.markerIds) ev.markerIds.forEach(id => { if (!allPoints.some(p => p.id === id)) { const base = findMarkerBaseData(id); if (base) allPoints.push(base); } });
    ev.home?.forEach(hid => { if(ev.markerIds && ev.markerIds.includes(hid)) { const m = DATA.markers.home.find(h => h.id === hid); if(m) allPoints.push(m); } });
    allPoints.forEach(p => {
        let px = p.x, py = p.y;
        if (px === undefined) { const base = findMarkerBaseData(p.id); if(base) { px = base.x; py = base.y; } }
        if (px !== undefined) { if(px < minX) minX=px; if(px > maxX) maxX=px; if(py < minY) minY=py; if(py > maxY) maxY=py; }
    });
    if(minX !== Infinity) { const padding = 30; animateSVGView((minX + maxX)/2, (minY + maxY)/2, (maxX - minX) + padding*2, (maxY - minY) + padding*2, true); }
    dom.eventBackBtn.classList.add('active'); dom.overlayBottom.style.transform = 'translateY(100%)';
}

function returnFromEvent() {
    if(!state.eventFocused) return; dom.eventBackBtn.classList.remove('active'); clearHighlighting();
    if (state.returnToCountryMode) {
        dom.backBtn.style.left = '20px'; tween(0, -33.33, 600, (val) => { dom.leftPanel.style.left = `${val}%`; }, () => { if(state.savedLeftPanel) { dom.leftPanel.querySelector('h1').textContent = state.savedLeftPanel.title; dom.timeline.innerHTML = state.savedLeftPanel.html; dom.leftPanel.querySelector('h1').textContent = "Timeline"; buildTimeline(); } });
        animateBackToMainView(() => { state.eventFocused = false; state.focusedEvent = null; state.returnToCountryMode = false; updateAllMarkers(state.focusedCountryId); }, state.savedSVGState); 
    } else {
        transitionPanelContent('backward', () => { dom.leftPanel.querySelector('h1').textContent = state.savedLeftPanel.title; dom.timeline.innerHTML = state.savedLeftPanel.html; dom.timeline.querySelectorAll('.timeline-event').forEach((div, i) => { div._eventData = DATA.events[i]; }); rebindTimelineEvents(); });
        animateBackToMainView(() => { state.eventFocused = false; state.focusedEvent = null; updateAllMarkers(); }, state.savedSVGState); 
    }
    DATA.markers.home.forEach(m => document.getElementById(m.id)?.classList.remove('star-highlight'));
}

function clearHighlighting() { dom.markers.forEach(el => el.classList.remove('map-marker-highlight')); dom.timeline.querySelectorAll('.timeline-event').forEach(el => el.classList.remove('active-highlight')); }
function highlightMarkerAndTimeline(id) {
    if(!id) return; const marker = dom.markers.get(id); if(marker) marker.classList.add('map-marker-highlight');
    document.querySelectorAll(`.timeline-event[data-marker-id="${id}"]`).forEach(item => {
        item.classList.add('active-highlight');
        if (!DATA.markers.home.some(m => m.id === id)) {
            const container = dom.scrollArea, itemRect = item.getBoundingClientRect(), panelRect = container.getBoundingClientRect();
            container.scrollTo({ top: itemRect.top - panelRect.top + container.scrollTop - (container.clientHeight / 2) + (item.clientHeight / 2), behavior: 'smooth' });
        }
    });
}

function updateTimelineFade() {
    const panel = dom.scrollArea, center = panel.scrollTop + panel.clientHeight / 2, range = panel.clientHeight * 0.45; 
    dom.timeline.querySelectorAll('.timeline-event').forEach(el => {
        const elCenter = el.offsetTop + el.offsetHeight / 2;
        let op = Math.max(0.15, Math.min(1, 1 - (Math.abs(center - elCenter) / range))); 
        if (el.classList.contains('active-highlight') || el.matches(':hover')) op = 1;
        el.style.opacity = op;
    });
}

// 核心還原滿版演算法
function updateSVGTransform() {
    if (!dom.svg) return;
    const winW = window.innerWidth, winH = window.innerHeight, vb = dom.svg.viewBox.baseVal;
    
    // 最原始、最正確的滿版 (cover) 計算公式
    const getCoverSize = (frameW, frameH) => { 
        const sR = vb.width / vb.height, fR = frameW / frameH; 
        return (sR < fR) ? {w: frameW, h: frameW/sR} : {h: frameH, w: frameH*sR}; 
    };
    
    const s0 = getCoverSize(winW, winH); 
    const s1 = getCoverSize(winW * 2/3, winH); 
    
    const currW = s0.w + (s1.w - s0.w) * state.progress; 
    const currH = s0.h + (s1.h - s0.h) * state.progress;
    
    const cx0 = winW/2, cy0 = winH/2;
    const cx1 = winW/3 + (winW*2/3)/2, cy1 = winH/2;
    
    const curX = cx0 + (cx1 - cx0) * state.progress; 
    const curY = cy0 + (cy1 - cy0) * state.progress;
    
    dom.svg.style.width = `${currW}px`; 
    dom.svg.style.height = `${currH}px`; 
    dom.svg.style.transform = `translate(${curX - currW/2}px, ${curY - currH/2}px)`;
    updateAllMarkers();
}

function animateBackToMainView(onComplete, forcedTargetState = null) {
    state.animatingReturn = true; 
    const startW = parseFloat(dom.svg.style.width), startH = parseFloat(dom.svg.style.height), startM = new DOMMatrixReadOnly(getComputedStyle(dom.svg).transform);
    let targetW, targetH, targetX, targetY;
    if (forcedTargetState) {
        targetW = forcedTargetState.w; targetH = forcedTargetState.h; const tm = new DOMMatrixReadOnly(forcedTargetState.t); targetX = tm.m41; targetY = tm.m42;
    } else {
        const winW = window.innerWidth, winH = window.innerHeight, vb = dom.svg.viewBox.baseVal;
        const getCoverSize = (frameW, frameH) => { const sR = vb.width / vb.height, fR = frameW / frameH; return (sR < fR) ? {w: frameW, h: frameW/sR} : {h: frameH, w: frameH*sR}; };
        
        const s0 = getCoverSize(winW, winH);
        const s1 = getCoverSize(winW * 2/3, winH);
        
        targetW = s0.w + (s1.w - s0.w) * state.progress; 
        targetH = s0.h + (s1.h - s0.h) * state.progress;
        
        const cx0 = winW/2, cy0 = winH/2, cx1 = winW/3 + (winW*2/3)/2, cy1 = winH/2;
        targetX = (cx0 + (cx1 - cx0) * state.progress) - targetW/2; 
        targetY = (cy0 + (cy1 - cy0) * state.progress) - targetH/2;
    }
    tween(0, 1, 600, (val, eased) => {
        dom.svg.style.width = `${startW + (targetW - startW) * eased}px`; 
        dom.svg.style.height = `${startH + (targetH - startH) * eased}px`; 
        dom.svg.style.transform = `translate(${startM.m41 + (targetX - startM.m41) * eased}px, ${startM.m42 + (targetY - startM.m42) * eased}px)`;
        if (state.returnToCountryMode) updateAllMarkers(state.focusedCountryId); else updateAllMarkers();
    }, () => { state.animatingReturn = false; if(onComplete) onComplete(); });
}

function animateSVGView(cx, cy, targetW, targetH, offsetRightPanel = false) {
    const winW = window.innerWidth, winH = window.innerHeight, frameW = offsetRightPanel ? winW * 2/3 : winW, scale = Math.min(frameW / targetW, winH / targetH), vb = dom.svg.viewBox.baseVal;
    let screenCX = offsetRightPanel ? (winW/3 + (winW*2/3)/2) : winW / 2;
    const targetX = screenCX - cx * scale, targetY = winH/2 - cy * scale;
    const startW = parseFloat(dom.svg.style.width), startH = parseFloat(dom.svg.style.height), startM = new DOMMatrixReadOnly(getComputedStyle(dom.svg).transform);
    tween(0, 1, 600, (val, eased) => {
        dom.svg.style.width = `${startW + (vb.width * scale - startW) * eased}px`; dom.svg.style.height = `${startH + (vb.height * scale - startH) * eased}px`; 
        dom.svg.style.transform = `translate(${startM.m41 + (targetX - startM.m41) * eased}px, ${startM.m42 + (targetY - startM.m42) * eased}px)`;
        updateAllMarkers();
    });
}

function buildTimeline() {
    dom.timeline.innerHTML = '';
    const sorted = [...DATA.events].sort((a,b) => new Date(a.date.split('<')[0]) - new Date(b.date.split('<')[0]));
    sorted.forEach((ev, i) => dom.timeline.appendChild(createTimelineElement(ev, i)));
    updateTimelineFade(); rebindTimelineEvents();
}

function updateTimelineForEvent(ev, highlightMarkerId = null) {
    dom.leftPanel.querySelector('h1').textContent = ev.text; dom.timeline.innerHTML = '';
    let rawMarkers = [];
    if (ev.eventMarkers) rawMarkers.push(...ev.eventMarkers);
    if (ev.markerIds) ev.markerIds.forEach(mid => { if (!rawMarkers.some(m => m.id === mid)) { const base = findMarkerBaseData(mid); if (base) rawMarkers.push({ id: mid, city: base.city, date: ev.date }); } });
    const mergedMarkers = [];
    if (rawMarkers.length > 0) {
        let currentBlock = { city: rawMarkers[0].city, startDate: rawMarkers[0].date, endDate: rawMarkers[0].date, ids: [rawMarkers[0].id] };
        for (let i = 1; i < rawMarkers.length; i++) {
            const m = rawMarkers[i];
            if (m.city === currentBlock.city) { currentBlock.endDate = m.date; currentBlock.ids.push(m.id); }
            else { mergedMarkers.push(currentBlock); currentBlock = { city: m.city, startDate: m.date, endDate: m.date, ids: [m.id] }; }
        }
        mergedMarkers.push(currentBlock);
    }
    mergedMarkers.forEach((block) => {
        const el = document.createElement('div'); el.className = 'timeline-event'; el.dataset.markerId = block.ids[0]; 
        let dateDisplay = block.startDate !== block.endDate ? `${block.startDate}<br>${block.endDate}` : block.startDate;
        el.innerHTML = `<div class="tick"></div><div class="date">${dateDisplay}</div><div class="text">${block.city}</div>`;
        el.addEventListener('click', (e) => { e.stopPropagation(); showRichInfo(block.ids[0]); });
        el.addEventListener('mouseenter', () => { el.classList.add('active-highlight'); block.ids.forEach(id => { const marker = dom.markers.get(id); if(marker) marker.classList.add('map-marker-highlight'); }); });
        el.addEventListener('mouseleave', () => { el.classList.remove('active-highlight'); block.ids.forEach(id => { const marker = dom.markers.get(id); if(marker) marker.classList.remove('map-marker-highlight'); }); });
        dom.timeline.appendChild(el);
    });
    if (ev.text === 'Belgium Trip') {
        const container = document.createElement('div'); container.className = 'timeline-story-link';
        const btn = document.createElement('div'); btn.id = 'moreStoryBtn'; btn.textContent = 'More Story'; 
        btn.onclick = (e) => { e.stopPropagation(); window.location.href = 'Belgium_Trip.html'; };
        container.appendChild(btn); dom.timeline.appendChild(container);
    }
    dom.scrollArea.scrollTop = 0; updateTimelineFade();
    if (highlightMarkerId) setTimeout(() => highlightMarkerAndTimeline(highlightMarkerId), 100); 
}

function createTimelineElement(ev, i) {
    const div = document.createElement('div'); div.className = 'timeline-event'; div.dataset.markerId = ""; 
    div.innerHTML = `<div class="tick"></div><div class="date">${ev.date}</div><div class="text">${ev.text}</div>`; div._eventData = ev; return div;
}

function rebindTimelineEvents() {
    dom.timeline.querySelectorAll('.timeline-event').forEach(div => {
        const ev = div._eventData; if (!ev) return;
        div.addEventListener("mouseenter", () => {
            state.stopoverActive = true;
            if(!state.eventFocused) {
                ev.countryCandidates?.forEach(c => { const el = dom.svg.querySelector('#'+c); if(el) el.classList.add('country-highlight'); });
                ev.home?.forEach(hid => document.getElementById(hid)?.classList.add('star-highlight'));
                ev.markerIds?.forEach(mid => { const m = dom.markers.get(mid); if(m) { m.style.opacity = 1; m.style.pointerEvents = "auto"; } });
            }
        });
        div.addEventListener("mouseleave", () => {
            state.stopoverActive = false;
            if(!state.eventFocused) { clearMapHover(); DATA.markers.home.forEach(m => document.getElementById(m.id)?.classList.remove('star-highlight')); updateAllMarkers(); }
        });
        div.addEventListener("click", () => focusOnEvent(ev));
    });
}

/* =========================================================
   照片飛梭核心功能區塊
========================================================= */
function setupIntroGallery() {
    const gallery = document.getElementById('introPhotos');
    let photos = [];
    
    if (window.DATA && window.DATA.events) {
        window.DATA.events.forEach(ev => {
            if(ev.eventMarkers) ev.eventMarkers.forEach(m => {
                // 智慧判斷路徑
                if(m.img) {
                    let path = m.img.includes("/") ? m.img : `Photos/${m.city}/${m.img}`;
                    photos.push(path);
                }
                // 支援讀取 photo1, photo2, photo3 等多張照片
                if(m.notes) m.notes.forEach(n => { 
                    Object.keys(n).forEach(key => {
                        if (key.startsWith('photo') && n[key]) photos.push(n[key]);
                    });
                });
            });
        });
    }
    if (window.DATA && window.DATA.markers) {
        Object.values(window.DATA.markers).forEach(arr => {
            arr.forEach(m => { 
                if(m.img) {
                    let path = m.img.includes("/") ? m.img : `Photos/${m.city}/${m.img}`;
                    if (!photos.includes(path)) photos.push(path); 
                }
            });
        });
    }

    photos = photos.sort(() => 0.5 - Math.random()).slice(0, 30); 

    photos.forEach(src => {
        const img = document.createElement('img');
        img.src = src; img.className = 'intro-photo';
        const angle = Math.random() * Math.PI * 2;
        const radius = 300 + Math.random() * 1200; 
        const x = Math.cos(angle) * radius;
        const y = Math.sin(angle) * radius;
        const z = -Math.random() * 12000 - 800; 
        
        img.dataset.origX = x; img.dataset.origY = y; img.dataset.origZ = z;
        gallery.appendChild(img);
    });
}

function startAnimationLoop() {
    const photosAndTitle = document.querySelectorAll('.intro-photo, .intro-title-content');
    const bgContainer = document.getElementById('bgImageContainer');
    
    const TIMELINE_DEPTH = 4000; 
    const MAX_DEPTH = state.WARP_DEPTH + TIMELINE_DEPTH;

    function animate() {
        if (!state.countryFocused && !state.eventFocused && !state.animatingReturn) {
            state.scrollDepth += state.velocity;
            state.velocity *= 0.85; 
            
            if (state.scrollDepth < 0) { state.scrollDepth = 0; state.velocity = 0; }
            if (state.scrollDepth > MAX_DEPTH) { state.scrollDepth = MAX_DEPTH; state.velocity = 0; }
            
            // 強制精準歸零機制，解決頂部標題可能沒有100%顯示的Bug
            if (state.scrollDepth > 0 && state.scrollDepth < 50 && Math.abs(state.velocity) < 1) {
                state.scrollDepth = 0;
                state.velocity = 0;
            }

            if (state.scrollDepth <= state.WARP_DEPTH) {
                // --- Phase 1: 飛梭模式 ---
                dom.bgContainer.style.pointerEvents = "none"; // 【地圖不可互動】

                let warpProgress = state.scrollDepth / state.WARP_DEPTH;
                
                // 【地圖放大曲線】使用 4 次方，讓地圖在最後才急速衝到面前
                let mapScale = 0.05 + (0.95 * Math.pow(warpProgress, 4)); 
                bgContainer.style.opacity = Math.min(1, warpProgress * 2.5); 
                
                if(dom.svg) {
                    const winW = window.innerWidth, winH = window.innerHeight, vb = dom.svg.viewBox.baseVal;
                    const getCoverSize = (fW, fH) => { const sR = vb.width / vb.height, fR = fW / fH; return (sR < fR) ? {w: fW, h: fW/sR} : {h: fH, w: fH*sR}; };
                    const s0 = getCoverSize(winW, winH);
                    dom.svg.style.width = `${s0.w}px`; dom.svg.style.height = `${s0.h}px`;
                    dom.svg.style.transform = `translate(${(winW - s0.w)/2}px, ${(winH - s0.h)/2}px) scale(${mapScale})`;
                }

                photosAndTitle.forEach(el => {
                    const oz = el.dataset.origZ ? parseFloat(el.dataset.origZ) : 0;
                    const ox = el.dataset.origX ? parseFloat(el.dataset.origX) : 0;
                    const oy = el.dataset.origY ? parseFloat(el.dataset.origY) : 0;
                    const currentZ = oz + state.scrollDepth;
                    
                    let op = 1.0; // 【所有照片完全不透明】
                    
                    if (currentZ > 100) op = 1.0 - ((currentZ - 100) / 600); 
                    
                    // 純靠 opacity 隱藏，避免 visibility 卡頓造成退回時消失
                    if (currentZ > 800 || op <= 0) {
                        el.style.opacity = 0;
                    } else {
                        el.style.opacity = op;
                    }
                    el.style.transform = `translate(-50%, -50%) translate3d(${ox}px, ${oy}px, ${currentZ}px)`;
                });

                state.progress = 0;
                dom.leftPanel.style.left = `-33.33%`; dom.leftPanel.style.opacity = 0;
                
                dom.warpMask.style.opacity = 0.7 - (warpProgress * 0.5);
                
                updateAllMarkers();

            } else {
                // --- Phase 2: 地圖右移與 Timeline ---
                dom.bgContainer.style.pointerEvents = "auto"; // 【地圖恢復可互動】
                bgContainer.style.opacity = 1;
                
                state.progress = (state.scrollDepth - state.WARP_DEPTH) / TIMELINE_DEPTH;
                const panelPhase = Math.min(Math.max((state.progress) / 1, 0), 1);
                
                dom.leftPanel.style.left = `${-33.33 + 33.33 * panelPhase}%`;
                dom.leftPanel.style.opacity = panelPhase;
                
                dom.warpMask.style.opacity = 0.2 - (panelPhase * 0.2); 
                
                if(dom.svg) dom.svg.style.transform = ''; 
                updateSVGTransform(); 
            }
        }
        requestAnimationFrame(animate);
    }
    animate();
}

function init() {
    Object.entries(DATA.markers).forEach(([countryCode, cityList]) => {
        cityList.forEach(city => { city.country = countryCode; });
    });

    const onWheel = e => { 
        // 【Timeline 滾動鎖定】
        const isInsidePanel = e.target.closest('#leftPanel');
        if (isInsidePanel && state.scrollDepth >= state.WARP_DEPTH) {
            if (dom.scrollArea.scrollTop > 0 && e.deltaY < 0) return; 
        }
        
        // 【動態物理加速】: 越接近地圖速度越快，最高提速 5.5 倍
        let speedMultiplier = 1;
        if (state.scrollDepth <= state.WARP_DEPTH) {
            let progress = Math.max(0, state.scrollDepth / state.WARP_DEPTH);
            speedMultiplier = 1 + Math.pow(progress, 3) * 4.5; 
        }
        
        state.velocity += e.deltaY * 0.8 * speedMultiplier; 
    };
    
    window.addEventListener('wheel', onWheel, { passive: false }); 
    
    setupIntroGallery();

    dom.scrollArea.addEventListener('scroll', () => {
        updateTimelineFade();
        const el = dom.scrollArea;
        if (!state.countryFocused && !state.eventFocused) {
            const dist = el.scrollHeight - el.scrollTop - el.clientHeight;
            dom.overlayBottom.style.transform = dist < 50 ? 'translateY(0)' : 'translateY(100%)';
        } else { dom.overlayBottom.style.transform = 'translateY(100%)'; }
    });

    dom.backBtn.addEventListener('click', returnFromCountryFocus); 
    dom.eventBackBtn.addEventListener('click', returnFromEvent);
    window.addEventListener('click', (e) => { if (!e.target.closest('.rightPoint') && !e.target.closest('.timeline-event')) clearHighlighting(); });
    
    dom.markers.forEach((el, id) => {
        el.addEventListener('mouseenter', (e) => { 
             e.stopPropagation(); 
             if (state.eventFocused) { clearHighlighting(); highlightMarkerAndTimeline(id); }
             const data = findMarkerBaseData(id); updateCityTooltip(data ? data.city : (el.dataset.label || "City"), el); 
        });
        el.addEventListener('mouseleave', () => { updateCityTooltip(null); if (state.eventFocused) clearHighlighting(); });
        el.addEventListener('click', (e) => { e.stopPropagation(); dom.cityLabel.style.opacity = 0; showRichInfo(id); });
    });
    
    buildTimeline(); 
    initMap(); 
}

window.addEventListener('load', init);
window.addEventListener('resize', () => { if(!state.countryFocused && !state.eventFocused) updateSVGTransform(); });
</script>
</body>
</html>