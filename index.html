<!DOCTYPE html>
<html lang="zh-Hant">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"/>
<title>Bryan's Travel Map | Interactive Europe Map & 歐洲自由行足跡</title>
<meta name="description" content="Explore Europe with Bryan! An interactive 3D travel map tracking journeys from 2023 to 2026.">
<style>
/* --- 1. Reset & Base --- */
html, body { margin:0; padding:0; height:100%; overflow:hidden; font-family:Arial,sans-serif; background: #000; touch-action: none; }
a { text-decoration: none; color: inherit; }

/* --- 2. Layout & Map Container --- */
#bgImageContainer { 
    position:absolute; top:0; left:0; width:100%; height:100%; overflow:hidden; 
    opacity:0; z-index: 1; will-change: opacity; 
    pointer-events: none; 
}
/* 加上 transform-origin: center 讓縮放都以地圖中心為基準 */
#bgImageContainer svg { position:absolute; top:0; left:0; transform-origin: center center; will-change: transform, width, height; }

/* --- 3. Warp Speed 3D Layers --- */
#introPhotos {
    position: fixed; top: 0; left: 0; width: 100vw; height: 100vh;
    perspective: 800px; z-index: 5;
    overflow: hidden; pointer-events: none;
}
.intro-photo {
    position: absolute; left: 50%; top: 50%;
    transform-origin: center center;
    box-shadow: 0 10px 40px rgba(0,0,0,1);
    border-radius: 6px; width: 280px; max-width: 80vw; object-fit: cover;
    will-change: transform, opacity;
}

#warpMask {
    position: fixed; top: 0; left: 0; width: 100vw; height: 100vh;
    background: rgba(0,0,0,0.65); 
    z-index: 10; pointer-events: none;
    transition: opacity 0.5s ease;
}

#introTitle {
    position: fixed; top: 0; left: 0; width: 100vw; height: 100vh;
    perspective: 800px; z-index: 20; 
    pointer-events: none;
}
.intro-title-content {
    position: absolute; left: 50%; top: 50%;
    color: white; text-align: center;
    will-change: transform, opacity;
}
.intro-title-content h1 { font-size: 3.5em; margin: 0; text-shadow: 0 4px 20px rgba(0,0,0,0.8); white-space: nowrap; }
.intro-title-content h2 { font-size: 1.5em; margin: 10px 0 0; font-weight: normal; }

/* --- 4. Left Panel (Desktop) --- */
#leftPanel {
  position:absolute; top:0; left:-33.33%; width:33.33%; height:100%;
  background:#3f3f3f; color:#fff; display:flex; flex-direction:column;
  align-items:center; padding-top:0; overflow:hidden; opacity:0; z-index:30;
  transition: opacity 0.3s ease;
}
#panelContent { width: 100%; height: 100%; display: flex; flex-direction: column; align-items: center; position: relative; transition: transform 0.4s ease, opacity 0.4s ease; }
#leftPanel h1 { font-size:1.6em; font-weight:normal; text-align:center; margin: 0; padding: 40px 0 20px; width: 100%; flex-shrink: 0; z-index: 25; background-color: #3f3f3f; position: relative; box-shadow: 0 2px 10px rgba(0,0,0,0.2); }
#timelineScrollArea { flex-grow: 1; width: 100%; overflow-y: auto; overflow-x: hidden; scroll-behavior: smooth; scrollbar-width: none; -ms-overflow-style: none; position: relative; z-index: 10; }
#timelineScrollArea::-webkit-scrollbar { display: none; }

/* 桌面版 Timeline (垂直) */
#timeline { position:relative; width:4px; background: rgba(255,255,255,0.3); margin:0 auto; padding-top: 0; padding-bottom: 0; min-height: 100%; display: flex; flex-direction: column; align-items: center; }
#timeline::before { content: ''; display: block; width: 100%; height: 45vh; flex-shrink: 0; }
#timeline::after { content: ''; display: block; width: 100%; height: 45vh; flex-shrink: 0; }
#leftPanel .fadeMask { position:absolute; top:80px; left:0; width:100%; height:80px; pointer-events:none; background: linear-gradient(to bottom, #3f3f3f 10%, transparent 100%); z-index:20; }

/* 桌面版 Timeline Events */
.timeline-event { position: relative; width: 100%; cursor: pointer; padding: 6px 0; margin-bottom: 100px; transition: opacity 0.2s ease, transform 0.2s ease; opacity: 0.3; display: flex; justify-content: center; align-items: center; flex-shrink: 0; }
.timeline-event:last-child { margin-bottom: 0; }
.timeline-event .tick { width:10px; height:2px; background:rgba(255,255,255,0.8); position:absolute; left: 50%; margin-left: -5px; z-index:2; transition: all 0.2s ease; }
.timeline-event .date { position:absolute; right: 50%; margin-right: 20px; width:100px; text-align:right; font-size:12px; color:#ddd; z-index:2; white-space: normal; line-height: 1.4; }
.timeline-event .text { position:absolute; left: 50%; margin-left: 20px; font-size:14px; color:#fff; z-index:2; white-space:nowrap; transition: color 0.2s; }
.timeline-event:hover .text { color: #ffd700; font-weight: bold; }
.timeline-event.active-highlight { opacity: 1 !important; transform: scale(1.1); }
.timeline-event.active-highlight .text { color: #ffd700; font-weight: bold; font-size: 1.25em; text-shadow: 0 0 8px rgba(255, 215, 0, 0.6); }
.timeline-event.active-highlight .tick { background: #ffd700; width: 18px; box-shadow: 0 0 8px rgba(255, 215, 0, 0.8); margin-left: -9px; }
.timeline-event.active-highlight .date { color: #fff; font-weight: bold; }
.timeline-story-link { margin-top: 40px; padding-bottom: 60px; display: flex; justify-content: center; width: 100%; }
#moreStoryBtn { padding: 10px 25px; background: #b16837; color: white; border-radius: 20px; cursor: pointer; font-size: 14px; font-weight: bold; transition: all 0.3s ease; border: 1px solid rgba(255,255,255,0.2); box-shadow: 0 4px 15px rgba(0,0,0,0.3); opacity: 1; }
#moreStoryBtn:hover { background: #d4824b; transform: scale(1.05); }

/* --- 6. Controls & Overlays --- */
.overlay-bottom { position: fixed; left: 0; bottom: 0; width: 100vw; height: 6vh; background: rgba(0,0,0,0.7); display: flex; justify-content: center; align-items: center; z-index: 45; transform: translateY(100%); transition: transform 0.4s ease; }
.overlay-bottom .inner { display:flex; align-items:center; gap:12px; font-size:16px; color:#fff; }
.overlay-bottom a { padding:4px 6px; cursor:pointer; }
#backButton { position: fixed; top: 20px; left: -80px; width: 60px; height: 40px; background: rgba(0,0,0,0.6); color: white; display: flex; justify-content: center; align-items: center; border-radius: 8px; cursor: pointer; z-index: 100; transition: left 0.5s ease; }
#eventBackButton { position: fixed; bottom: 20px; right: 20px; width: 100px; height: 40px; background: rgba(0,0,0,0.6); color: white; display: flex; justify-content: center; align-items: center; border-radius: 8px; cursor: pointer; z-index: 100; opacity: 0; transition: opacity 0.5s ease; pointer-events: none; }
#eventBackButton.active { opacity: 1; pointer-events: auto; }

/* --- 7. Tooltips & Rich Info Box --- */
#countryLabel { position:absolute; pointer-events:none; background:transparent; color: rgb(139, 84, 45); padding:0; font-size: 24px; font-weight: bold; white-space:nowrap; transform: translate(-50%, -50%) scale(1); transform-origin: center center; opacity:0; transition: opacity 0.4s ease, transform 0.6s cubic-bezier(0.175, 0.885, 0.32, 1.275); z-index:155; text-shadow: 1px 1px 0px rgba(255,255,255,0.4); }
#cityLabel { position: absolute; pointer-events: none; background: rgba(0, 0, 0, 0.8); color: #ededed; padding: 4px 8px; border-radius: 4px; font-size: 14px; font-weight: bold; white-space: nowrap; transform: translate(-50%, -120%); opacity: 0; transition: opacity 0.2s ease; z-index: 160; border: 1px solid rgba(255, 255, 255, 0.2); box-shadow: 0 2px 6px rgba(0,0,0,0.2); }
#infoOverlay { display:none; position:fixed; top:0; left:0; width:100vw; height:100vh; background:rgba(0,0,0,0.6); justify-content:center; align-items:center; z-index:300; backdrop-filter: blur(2px); }
#infoBox { background: #fff; color: #333; width: 90%; max-width: 380px; border-radius: 12px; overflow: hidden; box-shadow: 0 10px 25px rgba(0,0,0,0.5); display: flex; flex-direction: column; max-height: 80vh; }
.info-content { padding: 20px; display: flex; flex-direction: column; gap: 10px; overflow-y: auto; }
.info-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px; }
.info-city { font-size: 1.8em; font-weight: bold; color: #222; margin: 0; }
.explore-btn { padding: 4px 12px; background: #222; color: #fff; border-radius: 15px; font-size: 12px; cursor: pointer; transition: background 0.2s; border: none; white-space: nowrap; margin-left: 10px; }
.explore-btn:hover { background: #b16837; }
.visit-list { display: flex; flex-direction: column; gap: 12px; margin-top: 10px; }
.visit-item { background: #f9f9f9; border: 1px solid #eee; border-radius: 8px; padding: 12px; transition: transform 0.2s, box-shadow 0.2s; cursor: default; }
.visit-item.clickable-box { cursor: pointer; border-color: #ddd; }
.visit-item.clickable-box:hover { transform: translateY(-2px); box-shadow: 0 4px 8px rgba(0,0,0,0.1); border-color: #b16837; }
.visit-header { display: flex; justify-content: flex-start; align-items: center; margin-bottom: 6px; }
.visit-date-badge { background: #eef3ff; color: #b16837; font-weight: bold; font-size: 0.85em; padding: 4px 8px; border-radius: 4px; border: 1px solid #ddd; transition: all 0.2s; }
.visit-main-text { font-size: 1.1em; font-weight: bold; color: #333; margin-bottom: 4px; }
.visit-sub-text { font-size: 0.95em; color: #666; line-height: 1.4; }
.visit-item.stay-item { background: #333 !important; border-color: #444; color: #f4f4f4; }
.visit-item.stay-item .visit-date-badge { background: #b16837; color: #fff; border: none; }
.visit-item.stay-item .visit-sub-text { color: #ccc; }

/* --- 8. Map Elements --- */
.country-highlight { fill: rgb(203, 150, 97) !important; transition: fill .25s ease; }
.country-focus { fill: rgb(237, 186, 123) !important; }
.rightPoint { position:absolute; width:14px; height:14px; background:#b16837; border-radius:50%; pointer-events:none; opacity:0; transition:opacity .25s ease; z-index:200 !important; cursor: pointer; }
.rightPoint.star { width: 20px; height: 20px; background: #9889bd; clip-path: polygon(50% 0%, 61% 35%, 98% 35%, 68% 57%, 79% 91%, 50% 70%, 21% 91%, 32% 57%, 2% 35%, 39% 35%); z-index: 200 !important; }
.rightPoint.star-highlight { background-color: rgb(139, 42, 121) !important; }
.rightPoint.map-marker-highlight, .star.map-marker-highlight { background-color: #ffd700 !important; transform: scale(1.6) !important; box-shadow: 0 0 15px rgba(255, 215, 0, 0.8); z-index: 250 !important; border: 2px solid #fff; transition: all 0.2s ease; }
.event-route-line { display: none !important; }

/* --- 9. Mobile Responsive Layout --- */
@media (max-width: 768px) {
    .intro-title-content h1 { font-size: 2.2em; white-space: normal; line-height: 1.2; }
    .intro-title-content h2 { font-size: 1.2em; }
    
    #leftPanel {
        width: 100%; height: 22%; left: 0; top: auto; bottom: -25%; 
        box-shadow: 0 -4px 15px rgba(0,0,0,0.5);
    }
    #leftPanel.mobile-active { bottom: 0; }
    #leftPanel h1 { padding: 8px 0 5px; font-size: 1.1em; box-shadow: none; }

    #timelineScrollArea { 
        overflow-y: hidden; overflow-x: auto; display: flex; align-items: center; width: 100%;
        -webkit-overflow-scrolling: touch; 
    }
    
    #leftPanel .fadeMask { top: auto; left: 0; bottom: 0; width: 20px; height: 100%; background: linear-gradient(to right, #3f3f3f 10%, transparent 100%); z-index: 20; }
    #leftPanel::after { content: ''; position: absolute; right: 0; bottom: 0; width: 20px; height: calc(100% - 30px); background: linear-gradient(to left, #3f3f3f 10%, transparent 100%); z-index: 20; pointer-events: none; }

    #timeline { 
        display: flex; flex-direction: row; align-items: center; width: max-content; height: 100%; background: transparent; margin: 0; padding: 0 50vw; 
    }
    #timeline::before { content: ''; position: absolute; left: 0; right: 0; top: 50%; transform: translateY(-50%); height: 4px; background: rgba(255,255,255,0.3); z-index: 1; display: block; }
    #timeline::after { display: none; }

    .timeline-event { position: relative; width: 220px; height: 100%; margin: 0; flex-shrink: 0; z-index: 2; }
    .timeline-event .tick { position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%); width: 2px; height: 12px; margin: 0; z-index: 3; }
    .timeline-event .date { position: absolute; bottom: calc(50% + 15px); left: 50%; transform: translateX(-50%); right: auto; margin: 0; width: 100%; text-align: center; white-space: nowrap; font-size: 11px; }
    .timeline-event .text { position: absolute; top: calc(50% + 15px); left: 50%; transform: translateX(-50%); margin: 0; width: 100%; text-align: center; font-size: 13px; white-space: normal; }
    .timeline-event.active-highlight .tick { height: 20px; width: 4px; transform: translate(-50%, -50%); margin: 0; }
    .timeline-story-link { margin-top: 0; margin-left: 20px; padding-bottom: 0; align-items: center; z-index: 2; }
    
    #infoBox { width: 95%; max-height: 80vh; }
    #infoBox img { height: 140px; }
    
    .overlay-bottom { z-index: 200; }
    .overlay-bottom .inner { gap: 8px; font-size: 14px; flex-wrap: wrap; justify-content: center; text-align: center;}
    .overlay-bottom .sep { display: none; }
    
    #eventBackButton { bottom: calc(22% + 20px); right: 20px; z-index: 150; }
}
</style>
</head>
<body>

<div id="bgImageContainer"></div>

<div id="introPhotos"></div>
<div id="warpMask"></div>
<div id="introTitle">
    <div class="intro-title-content" data-orig-z="0">
        <h1>Tracing Europe with Bryan</h1>
        <h2>2023.09.17 - 2026.03.31</h2>
    </div>
</div>

<div id="leftPanel">
  <div id="panelContent">
      <h1>Timeline</h1>
      <div id="timelineScrollArea">
          <div id="timeline"></div>
      </div>
  </div>
  <div class="fadeMask"></div>
</div>

<div id="countryLabel"></div>
<div id="cityLabel"></div>

<div id="housePoint1" class="rightPoint star"></div>
<div id="housePoint2" class="rightPoint star"></div>
<div id="housePoint3" class="rightPoint star"></div>
<div id="housePoint4" class="rightPoint star"></div>
<div id="dePoint1" class="rightPoint"></div>
<div id="dePoint2" class="rightPoint"></div>
<div id="dePoint3" class="rightPoint"></div>
<div id="dePoint4" class="rightPoint"></div>
<div id="dePoint5" class="rightPoint"></div>
<div id="dePoint6" class="rightPoint"></div>
<div id="atPoint1" class="rightPoint"></div>
<div id="frtrip1" class="rightPoint"></div>
<div id="frtrip2" class="rightPoint"></div>
<div id="bePoint1" class="rightPoint"></div>
<div id="bePoint2" class="rightPoint"></div>
<div id="bePoint3" class="rightPoint"></div>
<div id="bePoint4" class="rightPoint"></div>
<div id="bePoint5" class="rightPoint"></div>
<div id="plPoint1" class="rightPoint"></div>
<div id="plPoint2" class="rightPoint"></div>
<div id="plPoint3" class="rightPoint"></div>
<div id="plPoint4" class="rightPoint"></div>
<div id="plPoint5" class="rightPoint"></div>
<div id="betrip1" class="rightPoint"></div>
<div id="betrip2" class="rightPoint"></div>
<div id="betrip3" class="rightPoint"></div>
<div id="betrip4" class="rightPoint"></div>
<div id="betrip5" class="rightPoint"></div>

<div id="overlayBottom" class="overlay-bottom" aria-hidden="true">
  <div class="inner">
    <a id="aboutLink">About</a> <span class="sep">|</span>
    <span class="label">BRYAN TRAVEL MAP</span> <span class="sep">|</span>
    <a id="contactLink">Contact</a>
  </div>
</div>

<div id="backButton">&#8592;</div>
<div id="eventBackButton">&#8592; Back</div>

<div id="infoOverlay">
  <div id="infoBox"></div>
</div>

<script src="data.js"></script>
<script>
const CONFIG = {
    scrollFactor: 0.002, friction: 0.85, 
    svgUrl: 'https://raw.githubusercontent.com/bryanCycwalker/Travel_Web_svg/refs/heads/main/Europe_map_new.svg'
};

const state = {
    WARP_DEPTH: 25000, 
    scrollDepth: 0, velocity: 0, bottomAccum: 0, progress: 0,
    countryFocused: false, focusedCountryId: null,
    eventFocused: false, focusedEvent: null,
    savedSVGState: null, savedLeftPanel: null,
    hoverEl: null, stopoverActive: false, animatingReturn: false,
    returnToCountryMode: false,
    isMobile: window.innerWidth <= 768,
    
    // --- 新增：使用者的手動縮放與平移狀態 ---
    userScale: 1,
    userPanX: 0,
    userPanY: 0,
    baseTranslateX: 0,
    baseTranslateY: 0,
    mapDragThreshold: false // 防止拖曳時觸發點擊
};

const DATA = window.DATA;

const dom = {
    bgContainer: document.getElementById('bgImageContainer'),
    leftPanel: document.getElementById('leftPanel'),
    panelContent: document.getElementById('panelContent'),
    scrollArea: document.getElementById('timelineScrollArea'),
    timeline: document.getElementById('timeline'),
    countryLabel: document.getElementById('countryLabel'),
    cityLabel: document.getElementById('cityLabel'),
    overlayBottom: document.getElementById('overlayBottom'),
    backBtn: document.getElementById('backButton'),
    eventBackBtn: document.getElementById('eventBackButton'),
    infoOverlay: document.getElementById('infoOverlay'),
    infoBox: document.getElementById('infoBox'),
    warpMask: document.getElementById('warpMask'),
    markers: new Map(),
    svg: null
};

document.querySelectorAll('.rightPoint').forEach(el => dom.markers.set(el.id, el));

function tween(from, to, duration, onUpdate, onComplete) {
    const startTime = performance.now();
    function loop(time) {
        const t = Math.min(1, (time - startTime) / duration);
        const eased = t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t; 
        const current = from + (to - from) * eased;
        onUpdate(current, eased);
        if (t < 1) requestAnimationFrame(loop);
        else if (onComplete) onComplete();
    }
    requestAnimationFrame(loop);
}

// 【新增】統一套用 SVG 縮放與平移的核心函式
function applyTransform() {
    if (!dom.svg) return;
    
    if (state.userScale <= 1) {
        state.userScale = 1;
        state.userPanX = 0;
        state.userPanY = 0;
    } else {
        // 邊界保護：確保平移不會超過放大的範圍，防止出現黑邊
        const svgW = parseFloat(dom.svg.style.width);
        const svgH = parseFloat(dom.svg.style.height);
        const maxPanX = (svgW * state.userScale - svgW) / 2;
        const maxPanY = (svgH * state.userScale - svgH) / 2;
        
        if (state.userPanX > maxPanX) state.userPanX = maxPanX;
        if (state.userPanX < -maxPanX) state.userPanX = -maxPanX;
        if (state.userPanY > maxPanY) state.userPanY = maxPanY;
        if (state.userPanY < -maxPanY) state.userPanY = -maxPanY;
    }
    
    // 合併系統運算的 Translate 與 使用者手動的 Pan/Scale
    dom.svg.style.transform = `translate(${state.baseTranslateX + state.userPanX}px, ${state.baseTranslateY + state.userPanY}px) scale(${state.userScale})`;
    
    // 更新所有 Marker 位置
    updateAllMarkers();
}

function transitionPanelContent(direction, updateCallback) {
    const el = dom.panelContent;
    const offset = direction === 'forward' ? -50 : 50;
    if (state.isMobile) el.style.transform = `translateX(${offset}px)`;
    else el.style.transform = `translateX(${offset}px)`;
    el.style.opacity = '0';
    
    setTimeout(() => {
        updateCallback();
        el.style.transition = 'none';
        const startPos = direction === 'forward' ? 50 : -50;
        if (state.isMobile) el.style.transform = `translateX(${startPos}px)`;
        else el.style.transform = `translateX(${startPos}px)`;
        
        void el.offsetWidth;
        el.style.transition = 'transform 0.4s ease, opacity 0.4s ease';
        el.style.transform = 'translate(0, 0)'; el.style.opacity = '1';
    }, 300);
}

function getCountryId(el) { if (!el) return null; const validKeys = Object.keys(DATA.markers); const clean = (id) => id ? id.trim().toLowerCase() : null; let currentId = clean(el.id); if (validKeys.includes(currentId)) return currentId; const parent = el.closest('g'); if (parent) { currentId = clean(parent.id); if (validKeys.includes(currentId)) return currentId; } return clean(el.id) || (parent ? clean(parent.id) : null); }
function getGenericOwner(id) { if (DATA.markers.home.some(m => m.id === id)) return 'home'; for (let key of Object.keys(DATA.markers)) { if (key === 'home') continue; if (DATA.markers[key].some(m => m.id === id)) return key; } return null; }
function findMarkerBaseData(id) {
    let found = DATA.markers.home.find(m => m.id === id); if (found) return found;
    for (let key of Object.keys(DATA.markers)) { if (key === 'home') continue; found = DATA.markers[key].find(m => m.id === id); if (found) return found; }
    for (let ev of DATA.events) { if (ev.eventMarkers) { found = ev.eventMarkers.find(m => m.id === id); if (found) return found; } }
    return null;
}

function showRichInfo(id) {
    dom.countryLabel.style.opacity = 0;
    dom.cityLabel.style.opacity = 0;

    const baseData = findMarkerBaseData(id);
    const cityName = baseData?.city || "Unknown City";

    let cId = baseData?.country || getGenericOwner(id);
    if (!cId) {
        if (id.startsWith('de') || id === 'housePoint1') cId = 'de';
        else if (id.startsWith('be')) cId = 'be';
        else if (id.startsWith('fr')) cId = 'fr';
    }

    const targetPage = { 'de': 'Germany.html', 'be': 'Belgium.html', 'fr': 'France.html' }[cId] || 'Germany.html';

    let listHTML = "";
    if (state.eventFocused && state.focusedEvent) {
        let cityMarkers = (state.focusedEvent.eventMarkers || []).filter(m => m.id === id);
        let processedGroups = [];

        cityMarkers.forEach(curr => {
            let last = processedGroups[processedGroups.length - 1];
            if (last && curr.stay && last.stay === curr.stay) {
                if ((new Date(curr.date) - new Date(last.endDate || last.date)) / 86400000 <= 1) {
                    last.endDate = curr.date; 
                    return; 
                }
            }
            processedGroups.push({ ...curr });
        });

        processedGroups.forEach(m => {
            let dateDisplay = m.endDate && m.endDate !== m.date ? `${m.date} ~ ${m.endDate}` : m.date;
            listHTML += `
                <div class="visit-item ${m.stay ? "stay-item" : ""}">
                    <div class="visit-header"><span class="visit-date-badge">${dateDisplay}</span></div>
                    <div class="visit-sub-text">${m.stay || m.desc || ""}</div>
                </div>`;
        });
    } else {
        let tripMap = new Map();
        DATA.events.forEach((ev, idx) => {
            let dates = [];
            if (ev.eventMarkers) ev.eventMarkers.filter(m => m.id === id).forEach(m => dates.push(m.date || ev.date));
            if (dates.length === 0 && ev.markerIds && ev.markerIds.includes(id)) dates.push(ev.date);
            if (dates.length > 0) {
                dates.sort();
                tripMap.set(idx, { name: ev.text, dateRange: dates.length > 1 ? `${dates[0]} ~ ${dates[dates.length - 1]}` : dates[0], idx: idx });
            }
        });
        tripMap.forEach(info => {
            listHTML += `
                <div class="visit-item clickable-box" onclick="window.handleDateTagClick(${info.idx}, '${id}')">
                    <div class="visit-header"><span class="visit-date-badge clickable-link">${info.dateRange}</span></div>
                    <div class="visit-main-text">${info.name}</div>
                </div>`;
        });
    }

    let imagePath = baseData?.img ? baseData.img : "";
    const imgHTML = imagePath ? `<img src="${imagePath}" alt="${cityName}">` : '';

    dom.infoBox.innerHTML = `
        ${imgHTML}
        <div class="info-content">
            <div class="info-header">
                <h3 class="info-city">${cityName}</h3>
                <button class="explore-btn" onclick="window.location.href='${targetPage}?city=${encodeURIComponent(cityName)}'">Explore More</button>
            </div>
            <div class="visit-list">${listHTML}</div>
        </div>`;
    dom.infoOverlay.style.display = "flex";
}

window.handleDateTagClick = function(eventIndex, highlightMarkerId) { 
    if (eventIndex < 0) return;
    const targetEvent = DATA.events[eventIndex];
    if (!targetEvent) return;
    dom.infoOverlay.style.display = "none";
    if (state.countryFocused) {
        state.returnToCountryMode = true;
        state.savedSVGState = { 
            w: parseFloat(dom.svg.style.width), 
            h: parseFloat(dom.svg.style.height), 
            x: state.baseTranslateX,
            y: state.baseTranslateY
        };
    } else state.returnToCountryMode = false;
    focusOnEvent(targetEvent, highlightMarkerId); 
}

dom.infoBox.addEventListener('click', (e) => e.stopPropagation());
dom.infoOverlay.addEventListener('click', () => { 
    dom.infoOverlay.style.display = "none"; 
    if (state.countryFocused) dom.countryLabel.style.opacity = 1;
});

async function initMap() {
    try {
        const resp = await fetch(CONFIG.svgUrl);
        dom.bgContainer.innerHTML = await resp.text();
        dom.svg = dom.bgContainer.querySelector('svg');
        const routeG = document.createElementNS("http://www.w3.org/2000/svg", "g");
        routeG.id = "routeLayer";
        dom.svg.appendChild(routeG); 
        if (!dom.svg.viewBox.baseVal.width) dom.svg.setAttribute('viewBox', `0 0 ${dom.svg.getAttribute('width') || 2000} ${dom.svg.getAttribute('height') || 1200}`);
        dom.svg.style.width = '100%'; dom.svg.style.height = '100%';
        setupMapInteractions();
        startAnimationLoop();
    } catch (e) { console.error("SVG Load Failed:", e); }
}

function setupMapInteractions() {
    dom.svg.querySelectorAll('path, polygon, rect, circle').forEach(el => {
        if (el.id && el.id.toLowerCase().includes("path")) return;
        el.style.cursor = "pointer";
        
        el.addEventListener("mouseenter", () => { handleMapHoverEnter(el); });
        el.addEventListener("mouseleave", () => { handleMapHoverLeave(); });
        el.addEventListener("click", (e) => { 
            e.stopPropagation(); 
            if (!state.eventFocused && !state.countryFocused) focusOnCountry(el); 
        });

        let touchTimer;
        el.addEventListener('touchstart', (e) => {
            if (state.eventFocused || state.progress < 0.1) return;
            touchTimer = setTimeout(() => {
                handleMapHoverEnter(el);
            }, 300);
        });
        el.addEventListener('touchend', (e) => {
            clearTimeout(touchTimer); 
            if (state.mapDragThreshold) return; // 【修復】如果是拖曳/縮放中，取消點擊進入國家的行為
            if (!state.eventFocused && !state.countryFocused) {
                 e.preventDefault(); 
                 focusOnCountry(el);
            }
        });
        el.addEventListener('touchmove', () => { clearTimeout(touchTimer); }); 
    });
}

function handleMapHoverEnter(el) {
    if (state.eventFocused || state.progress < 0.1) return;
    if (state.countryFocused && el.tagName !== 'circle') return; 
    state.hoverEl = el;
    const g = el.closest('g') || el;
    g.classList.add('country-highlight');
    g.querySelectorAll('*').forEach(c => c.classList.add('country-highlight'));
    let name = g.querySelector('title')?.textContent || g.id || el.id;
    if (name) updateTooltip(name, el, true);
    updateAllMarkers(getCountryId(el)); 
}

function handleMapHoverLeave() {
    if (state.countryFocused || state.eventFocused) return;
    state.hoverEl = null; clearMapHover(); dom.countryLabel.style.opacity = 0; updateAllMarkers(); 
}

function clearMapHover() { if(dom.svg) dom.svg.querySelectorAll('.country-highlight').forEach(el => el.classList.remove('country-highlight')); }

function updateTooltip(text, targetEl, isSVGElement = false) {
    if (!text || !dom.svg || !targetEl || (dom.countryLabel.dataset.locked === "true" && !isSVGElement)) return;
    dom.countryLabel.textContent = text; dom.countryLabel.style.opacity = 1;
    let x, y;
    if (isSVGElement) {
        const bbox = targetEl.getBBox(), pt = dom.svg.createSVGPoint(); 
        pt.x = bbox.x + bbox.width/2; pt.y = bbox.y + bbox.height/2;
        const screen = pt.matrixTransform(dom.svg.getScreenCTM()); x = screen.x; y = screen.y;
    } else {
        const rect = targetEl.getBoundingClientRect(); x = rect.left + rect.width/2; y = rect.top - 5;
    }
    dom.countryLabel.style.left = `${x}px`; dom.countryLabel.style.top = `${y}px`;
    dom.countryLabel.style.transform = dom.countryLabel.dataset.locked === "true" ? "translate(-50%, -50%) scale(2)" : "translate(-50%, -50%) scale(1)";
}

function updateCityTooltip(text, targetEl) {
    if (!text) { dom.cityLabel.style.opacity = 0; return; }
    dom.cityLabel.textContent = text;
    const rect = targetEl.getBoundingClientRect();
    dom.cityLabel.style.left = `${rect.left + rect.width / 2}px`;
    dom.cityLabel.style.top = `${rect.top}px`;
    dom.cityLabel.style.opacity = 1;
}

function updateAllMarkers(hoverCountryId = null) {
    if (!dom.svg) return;
    
    if (state.scrollDepth <= state.WARP_DEPTH) {
        dom.markers.forEach(el => {
            el.style.opacity = 0;
            el.style.pointerEvents = "none";
        });
        dom.countryLabel.style.opacity = 0;
        dom.cityLabel.style.opacity = 0;
        return;
    }

    const ctm = dom.svg.getScreenCTM();
    const activeCountry = hoverCountryId || state.focusedCountryId;
    if (state.countryFocused && dom.countryLabel.dataset.locked === "true") {
        const countryEl = document.querySelector('.country-focus');
        if (countryEl) updateTooltip(dom.countryLabel.textContent, countryEl, true);
    }
    const getScreenPos = (x, y) => { const pt = dom.svg.createSVGPoint(); pt.x = x; pt.y = y; return pt.matrixTransform(ctm); };
    
    dom.markers.forEach((el, id) => {
        let isVisible = false, targetX = 0, targetY = 0;
        if (state.eventFocused && state.focusedEvent) {
            if ((state.focusedEvent.markerIds || []).includes(id)) {
                isVisible = true; const evM = (state.focusedEvent.eventMarkers || []).find(m => m.id === id);
                if (evM && evM.x !== undefined) { targetX = evM.x; targetY = evM.y; } else { const base = findMarkerBaseData(id); if (base) { targetX = base.x; targetY = base.y; } }
            }
        } else if (DATA.markers.home.some(m => m.id === id)) { isVisible = true; const m = DATA.markers.home.find(x => x.id === id); targetX = m.x; targetY = m.y; }
        else if (activeCountry) {
            const genericOwner = getGenericOwner(id);
            if (genericOwner === activeCountry) { isVisible = true; const m = DATA.markers[activeCountry].find(x => x.id === id); targetX = m.x; targetY = m.y; }
            if (!isVisible) {
                for (let ev of DATA.events) {
                    if (ev.countryCandidates && ev.countryCandidates.includes(activeCountry)) {
                        const evM = ev.eventMarkers ? ev.eventMarkers.find(m => m.id === id) : null, inList = ev.markerIds ? ev.markerIds.includes(id) : false;
                        if (evM || inList) {
                            if (evM && evM.country && evM.country !== activeCountry) continue;
                            if (genericOwner && genericOwner !== activeCountry) continue;
                            isVisible = true;
                            if (evM && evM.x !== undefined) { targetX = evM.x; targetY = evM.y; } else { const base = findMarkerBaseData(id); if (base) { targetX = base.x; targetY = base.y; } }
                            break;
                        }
                    }
                }
            }
        }
        if (isVisible) {
            if (targetX !== undefined) {
                const screen = getScreenPos(targetX, targetY);
                el.style.left = `${screen.x - (el.classList.contains('star') ? 10 : 7)}px`;
                el.style.top = `${screen.y - (el.classList.contains('star') ? 10 : 7)}px`;
            }
            el.style.opacity = 1; el.style.pointerEvents = "auto";
        } else { el.style.opacity = 0; el.style.pointerEvents = "none"; }
    });
}

function focusOnCountry(el) {
    state.countryFocused = true; state.focusedCountryId = getCountryId(el);
    const g = el.closest('g') || el;
    updateTooltip(g.querySelector('title')?.textContent || g.id || el.id, el, true);
    dom.countryLabel.dataset.locked = "true";
    dom.countryLabel.style.transform = "translate(-50%, -50%) scale(2)"; 
    
    if (state.isMobile) {
        dom.leftPanel.classList.remove('mobile-active');
    } else {
        tween(0, -33.33, 600, (val) => { dom.leftPanel.style.left = `${val}%`; });
    }
    
    dom.backBtn.style.left = '20px'; 
    dom.svg.querySelectorAll('.country-focus').forEach(e => e.classList.remove('country-focus'));
    g.classList.add('country-focus'); g.querySelectorAll('*').forEach(e => e.classList.add('country-focus'));
    updateAllMarkers(state.focusedCountryId);
    
    const bbox = el.getBBox(), padding = 5;
    animateSVGView(bbox.x + bbox.width/2, bbox.y + bbox.height/2, bbox.width + padding*2, bbox.height + padding*2, false);
    dom.overlayBottom.style.transform = 'translateY(100%)';
}

function returnFromCountryFocus() {
    dom.svg.querySelectorAll('.country-focus').forEach(e => e.classList.remove('country-focus'));
    dom.backBtn.style.left = '-80px'; dom.leftPanel.querySelector('h1').textContent = "Timeline";
    delete dom.countryLabel.dataset.locked;
    dom.countryLabel.style.opacity = 0; dom.countryLabel.style.transform = "translate(-50%, -50%) scale(1)"; 
    buildTimeline();
    
    if (state.isMobile) {
        dom.leftPanel.classList.add('mobile-active');
    } else {
        tween(-33.33, 0, 600, (val) => { dom.leftPanel.style.left = `${val}%`; });
    }
    
    animateBackToMainView(() => { state.countryFocused = false; state.focusedCountryId = null; state.velocity = 0; state.returnToCountryMode = false; updateAllMarkers(null); });
}

function focusOnEvent(ev, highlightMarkerId = null) { 
    state.eventFocused = true; state.focusedEvent = ev;
    if (!state.returnToCountryMode) {
        state.savedLeftPanel = { title: dom.leftPanel.querySelector('h1').textContent, html: dom.timeline.innerHTML };
        state.savedSVGState = { 
            w: parseFloat(dom.svg.style.width), 
            h: parseFloat(dom.svg.style.height), 
            x: state.baseTranslateX,
            y: state.baseTranslateY 
        };
        transitionPanelContent('forward', () => updateTimelineForEvent(ev, highlightMarkerId));
    } else {
        dom.backBtn.style.left = '-80px'; 
        if (state.isMobile) {
            dom.leftPanel.classList.add('mobile-active');
        } else {
            tween(-33.33, 0, 600, (val) => { dom.leftPanel.style.left = `${val}%`; dom.leftPanel.style.opacity = 1; });
        }
        updateTimelineForEvent(ev, highlightMarkerId);
    }
    let minX=Infinity, maxX=-Infinity, minY=Infinity, maxY=-Infinity; const allPoints = [];
    if(ev.eventMarkers) allPoints.push(...ev.eventMarkers);
    if(ev.markerIds) ev.markerIds.forEach(id => { if (!allPoints.some(p => p.id === id)) { const base = findMarkerBaseData(id); if (base) allPoints.push(base); } });
    ev.home?.forEach(hid => { if(ev.markerIds && ev.markerIds.includes(hid)) { const m = DATA.markers.home.find(h => h.id === hid); if(m) allPoints.push(m); } });
    allPoints.forEach(p => {
        let px = p.x, py = p.y;
        if (px === undefined) { const base = findMarkerBaseData(p.id); if(base) { px = base.x; py = base.y; } }
        if (px !== undefined) { if(px < minX) minX=px; if(px > maxX) maxX=px; if(py < minY) minY=py; if(py > maxY) maxY=py; }
    });
    
    if(minX !== Infinity) { 
        const padding = 30; 
        animateSVGView((minX + maxX)/2, (minY + maxY)/2, (maxX - minX) + padding*2, (maxY - minY) + padding*2, true); 
    }
    dom.eventBackBtn.classList.add('active'); dom.overlayBottom.style.transform = 'translateY(100%)';
}

function returnFromEvent() {
    if(!state.eventFocused) return; dom.eventBackBtn.classList.remove('active'); clearHighlighting();
    if (state.returnToCountryMode) {
        dom.backBtn.style.left = '20px'; 
        if(state.isMobile) { dom.leftPanel.classList.remove('mobile-active'); }
        else { tween(0, -33.33, 600, (val) => { dom.leftPanel.style.left = `${val}%`; }, () => { if(state.savedLeftPanel) { dom.leftPanel.querySelector('h1').textContent = state.savedLeftPanel.title; dom.timeline.innerHTML = state.savedLeftPanel.html; dom.leftPanel.querySelector('h1').textContent = "Timeline"; buildTimeline(); } }); }
        animateBackToMainView(() => { state.eventFocused = false; state.focusedEvent = null; state.returnToCountryMode = false; updateAllMarkers(state.focusedCountryId); }, state.savedSVGState); 
    } else {
        transitionPanelContent('backward', () => { dom.leftPanel.querySelector('h1').textContent = state.savedLeftPanel.title; dom.timeline.innerHTML = state.savedLeftPanel.html; dom.timeline.querySelectorAll('.timeline-event').forEach((div, i) => { div._eventData = DATA.events[i]; }); rebindTimelineEvents(); });
        animateBackToMainView(() => { state.eventFocused = false; state.focusedEvent = null; updateAllMarkers(); }, state.savedSVGState); 
    }
    DATA.markers.home.forEach(m => document.getElementById(m.id)?.classList.remove('star-highlight'));
}

function clearHighlighting() { dom.markers.forEach(el => el.classList.remove('map-marker-highlight')); dom.timeline.querySelectorAll('.timeline-event').forEach(el => el.classList.remove('active-highlight')); }
function highlightMarkerAndTimeline(id) {
    if(!id) return; const marker = dom.markers.get(id); if(marker) marker.classList.add('map-marker-highlight');
    document.querySelectorAll(`.timeline-event[data-marker-id="${id}"]`).forEach(item => {
        item.classList.add('active-highlight');
        if (!DATA.markers.home.some(m => m.id === id)) {
            const container = dom.scrollArea, itemRect = item.getBoundingClientRect(), panelRect = container.getBoundingClientRect();
            if (state.isMobile) {
                container.scrollTo({ left: itemRect.left - panelRect.left + container.scrollLeft - (container.clientWidth / 2) + (item.clientWidth / 2), behavior: 'smooth' });
            } else {
                container.scrollTo({ top: itemRect.top - panelRect.top + container.scrollTop - (container.clientHeight / 2) + (item.clientHeight / 2), behavior: 'smooth' });
            }
        }
    });
}

function updateTimelineFade() {
    const panel = dom.scrollArea;
    if (state.isMobile) {
        const center = panel.scrollLeft + panel.clientWidth / 2;
        const range = panel.clientWidth * 0.45;
        dom.timeline.querySelectorAll('.timeline-event').forEach(el => {
            const elCenter = el.offsetLeft + el.offsetWidth / 2;
            let op = Math.max(0.15, Math.min(1, 1 - (Math.abs(center - elCenter) / range))); 
            if (el.classList.contains('active-highlight') || el.matches(':hover')) op = 1;
            el.style.opacity = op;
        });
    } else {
        const center = panel.scrollTop + panel.clientHeight / 2;
        const range = panel.clientHeight * 0.45;
        dom.timeline.querySelectorAll('.timeline-event').forEach(el => {
            const elCenter = el.offsetTop + el.offsetHeight / 2;
            let op = Math.max(0.15, Math.min(1, 1 - (Math.abs(center - elCenter) / range))); 
            if (el.classList.contains('active-highlight') || el.matches(':hover')) op = 1;
            el.style.opacity = op;
        });
    }
}

function updateSVGTransform() {
    if (!dom.svg) return;
    const winW = window.innerWidth, winH = window.innerHeight, vb = dom.svg.viewBox.baseVal;
    const vbW = vb.width || 2000, vbH = vb.height || 1200;
    
    const getCoverSize = (fW, fH) => { 
        const sR = vbW / vbH, fR = fW / fH; 
        return (sR < fR) ? {w: fW, h: fW/sR} : {h: fH, w: fH*sR}; 
    };
    
    const s0 = getCoverSize(winW, winH); 
    const cx0 = winW / 2, cy0 = winH / 2;
    
    let frameW, frameH, cx1, cy1;
    if (state.isMobile) {
        frameW = winW;        
        frameH = winH * 0.78; 
        cx1 = winW / 2;       
        cy1 = winH * 0.39;    
    } else {
        frameW = winW * 2/3;  
        frameH = winH;        
        cx1 = winW/3 + frameW/2; 
        cy1 = winH / 2;       
    }
    
    const s1 = getCoverSize(frameW, frameH); 
    
    const currW = s0.w + (s1.w - s0.w) * state.progress; 
    const currH = s0.h + (s1.h - s0.h) * state.progress;
    const curX = cx0 + (cx1 - cx0) * state.progress; 
    const curY = cy0 + (cy1 - cy0) * state.progress;
    
    dom.svg.style.width = `${currW}px`; 
    dom.svg.style.height = `${currH}px`; 
    
    // 更新系統基本座標，並觸發合併 Transform
    state.baseTranslateX = curX - currW/2;
    state.baseTranslateY = curY - currH/2;
    applyTransform();
}

function animateBackToMainView(onComplete, forcedTargetState = null) {
    state.animatingReturn = true; 
    const startW = parseFloat(dom.svg.style.width), startH = parseFloat(dom.svg.style.height);
    let targetW, targetH, targetX, targetY;
    
    const startX = state.baseTranslateX;
    const startY = state.baseTranslateY;
    const startUserScale = state.userScale;
    const startUserPanX = state.userPanX;
    const startUserPanY = state.userPanY;
    
    if (forcedTargetState) {
        targetW = forcedTargetState.w; targetH = forcedTargetState.h; 
        targetX = forcedTargetState.x; targetY = forcedTargetState.y;
    } else {
        const winW = window.innerWidth, winH = window.innerHeight, vb = dom.svg.viewBox.baseVal;
        const vbW = vb.width || 2000, vbH = vb.height || 1200;
        const getCoverSize = (fW, fH) => { const sR = vbW / vbH, fR = fW / fH; return (sR < fR) ? {w: fW, h: fW/sR} : {h: fH, w: fH*sR}; };
        
        const s0 = getCoverSize(winW, winH);
        
        let frameW, frameH, cx1, cy1;
        if (state.isMobile) {
            frameW = winW; frameH = winH * 0.78;
            cx1 = winW / 2; cy1 = winH * 0.39;
        } else {
            frameW = winW * 2/3; frameH = winH;
            cx1 = winW/3 + frameW/2; cy1 = winH / 2;
        }
        const s1 = getCoverSize(frameW, frameH);
        
        targetW = s0.w + (s1.w - s0.w) * state.progress; 
        targetH = s0.h + (s1.h - s0.h) * state.progress;
        
        const curX = (winW/2) + (cx1 - winW/2) * state.progress; 
        const curY = (winH/2) + (cy1 - winH/2) * state.progress;
        
        targetX = curX - targetW/2; 
        targetY = curY - targetH/2;
    }
    tween(0, 1, 600, (val, eased) => {
        dom.svg.style.width = `${startW + (targetW - startW) * eased}px`; 
        dom.svg.style.height = `${startH + (targetH - startH) * eased}px`; 
        
        state.baseTranslateX = startX + (targetX - startX) * eased;
        state.baseTranslateY = startY + (targetY - startY) * eased;
        
        // 將使用者的手動縮放與平移平滑重置歸零
        state.userScale = startUserScale + (1 - startUserScale) * eased;
        state.userPanX = startUserPanX + (0 - startUserPanX) * eased;
        state.userPanY = startUserPanY + (0 - startUserPanY) * eased;
        
        applyTransform();
    }, () => { state.animatingReturn = false; if(onComplete) onComplete(); });
}

function animateSVGView(cx, cy, targetW, targetH, offsetRightPanel = false) {
    const winW = window.innerWidth, winH = window.innerHeight;
    
    let frameW = winW, frameH = winH;
    let screenCX = winW / 2, screenCY = winH / 2;
    
    if (offsetRightPanel) {
        if (state.isMobile) {
            frameW = winW;
            frameH = winH * 0.78;
            screenCY = winH * 0.39;
        } else {
            frameW = winW * 2/3;
            frameH = winH;
            screenCX = winW/3 + frameW/2;
        }
    }
    
    const scale = Math.min(frameW / targetW, frameH / targetH);
    
    let vbW = 2000, vbH = 1200;
    if (dom.svg && dom.svg.viewBox && dom.svg.viewBox.baseVal && dom.svg.viewBox.baseVal.width > 0) {
        vbW = dom.svg.viewBox.baseVal.width;
        vbH = dom.svg.viewBox.baseVal.height;
    }

    const targetX = screenCX - cx * scale, targetY = screenCY - cy * scale;
    const startW = parseFloat(dom.svg.style.width), startH = parseFloat(dom.svg.style.height);
    
    const startX = state.baseTranslateX;
    const startY = state.baseTranslateY;
    const startUserScale = state.userScale;
    const startUserPanX = state.userPanX;
    const startUserPanY = state.userPanY;

    tween(0, 1, 600, (val, eased) => {
        dom.svg.style.width = `${startW + (vbW * scale - startW) * eased}px`; dom.svg.style.height = `${startH + (vbH * scale - startH) * eased}px`; 
        
        state.baseTranslateX = startX + (targetX - startX) * eased;
        state.baseTranslateY = startY + (targetY - startY) * eased;
        
        // 進入焦點時，平滑重置手動縮放，確保目標準確
        state.userScale = startUserScale + (1 - startUserScale) * eased;
        state.userPanX = startUserPanX + (0 - startUserPanX) * eased;
        state.userPanY = startUserPanY + (0 - startUserPanY) * eased;
        
        applyTransform();
    });
}

function buildTimeline() {
    dom.timeline.innerHTML = '';
    const sorted = [...DATA.events].sort((a,b) => new Date(a.date.split('<')[0]) - new Date(b.date.split('<')[0]));
    sorted.forEach((ev, i) => dom.timeline.appendChild(createTimelineElement(ev, i)));
    updateTimelineFade(); rebindTimelineEvents();
}

function updateTimelineForEvent(ev, highlightMarkerId = null) {
    dom.leftPanel.querySelector('h1').textContent = ev.text; dom.timeline.innerHTML = '';
    let rawMarkers = [];
    if (ev.eventMarkers) rawMarkers.push(...ev.eventMarkers);
    if (ev.markerIds) ev.markerIds.forEach(mid => { if (!rawMarkers.some(m => m.id === mid)) { const base = findMarkerBaseData(mid); if (base) rawMarkers.push({ id: mid, city: base.city, date: ev.date }); } });
    const mergedMarkers = [];
    if (rawMarkers.length > 0) {
        let currentBlock = { city: rawMarkers[0].city, startDate: rawMarkers[0].date, endDate: rawMarkers[0].date, ids: [rawMarkers[0].id] };
        for (let i = 1; i < rawMarkers.length; i++) {
            const m = rawMarkers[i];
            if (m.city === currentBlock.city) { currentBlock.endDate = m.date; currentBlock.ids.push(m.id); }
            else { mergedMarkers.push(currentBlock); currentBlock = { city: m.city, startDate: m.date, endDate: m.date, ids: [m.id] }; }
        }
        mergedMarkers.push(currentBlock);
    }
    mergedMarkers.forEach((block) => {
        const el = document.createElement('div'); el.className = 'timeline-event'; el.dataset.markerId = block.ids[0]; 
        
        let dateDisplay;
        if (state.isMobile) {
            dateDisplay = block.startDate !== block.endDate ? `${block.startDate} ~ ${block.endDate}` : block.startDate;
        } else {
            dateDisplay = block.startDate !== block.endDate ? `${block.startDate}<br>${block.endDate}` : block.startDate;
        }
        
        el.innerHTML = `<div class="tick"></div><div class="date">${dateDisplay}</div><div class="text">${block.city}</div>`;
        el.addEventListener('click', (e) => { e.stopPropagation(); showRichInfo(block.ids[0]); });
        el.addEventListener('mouseenter', () => { el.classList.add('active-highlight'); block.ids.forEach(id => { const marker = dom.markers.get(id); if(marker) marker.classList.add('map-marker-highlight'); }); });
        el.addEventListener('mouseleave', () => { el.classList.remove('active-highlight'); block.ids.forEach(id => { const marker = dom.markers.get(id); if(marker) marker.classList.remove('map-marker-highlight'); }); });
        dom.timeline.appendChild(el);
    });
    if (ev.text === 'Belgium Trip') {
        const container = document.createElement('div'); container.className = 'timeline-story-link';
        const btn = document.createElement('div'); btn.id = 'moreStoryBtn'; btn.textContent = 'More Story'; 
        btn.onclick = (e) => { e.stopPropagation(); window.location.href = 'Belgium_Trip.html'; };
        container.appendChild(btn); dom.timeline.appendChild(container);
    }
    dom.scrollArea.scrollTop = 0; dom.scrollArea.scrollLeft = 0; updateTimelineFade();
    if (highlightMarkerId) setTimeout(() => highlightMarkerAndTimeline(highlightMarkerId), 100); 
}

function createTimelineElement(ev, i) {
    const div = document.createElement('div'); div.className = 'timeline-event'; div.dataset.markerId = ""; 
    
    let formattedDate = ev.date;
    if (state.isMobile && formattedDate.includes('<br>')) {
        formattedDate = formattedDate.replace('<br>', ' ~ ');
    }
    
    div.innerHTML = `<div class="tick"></div><div class="date">${formattedDate}</div><div class="text">${ev.text}</div>`; div._eventData = ev; return div;
}

function rebindTimelineEvents() {
    dom.timeline.querySelectorAll('.timeline-event').forEach(div => {
        const ev = div._eventData; if (!ev) return;
        div.addEventListener("mouseenter", () => {
            state.stopoverActive = true;
            if(!state.eventFocused) {
                ev.countryCandidates?.forEach(c => { const el = dom.svg.querySelector('#'+c); if(el) el.classList.add('country-highlight'); });
                ev.home?.forEach(hid => document.getElementById(hid)?.classList.add('star-highlight'));
                ev.markerIds?.forEach(mid => { const m = dom.markers.get(mid); if(m) { m.style.opacity = 1; m.style.pointerEvents = "auto"; } });
            }
        });
        div.addEventListener("mouseleave", () => {
            state.stopoverActive = false;
            if(!state.eventFocused) { clearMapHover(); DATA.markers.home.forEach(m => document.getElementById(m.id)?.classList.remove('star-highlight')); updateAllMarkers(); }
        });
        div.addEventListener("click", () => focusOnEvent(ev));
    });
}

function setupIntroGallery() {
    const gallery = document.getElementById('introPhotos');
    let photos = [];
    
    if (window.DATA && window.DATA.events) {
        window.DATA.events.forEach(ev => {
            if(ev.eventMarkers) ev.eventMarkers.forEach(m => {
                if(m.img) photos.push(m.img);
                if(m.notes) m.notes.forEach(n => { 
                    Object.keys(n).forEach(key => {
                        if (key.startsWith('photo') && n[key]) photos.push(n[key]);
                    });
                });
            });
        });
    }
    if (window.DATA && window.DATA.markers) {
        Object.values(window.DATA.markers).forEach(arr => {
            arr.forEach(m => { 
                if(m.img && !photos.includes(m.img)) photos.push(m.img); 
            });
        });
    }

    photos = photos.sort(() => 0.5 - Math.random()).slice(0, 30); 

    photos.forEach(src => {
        const img = document.createElement('img');
        img.src = src; img.className = 'intro-photo';
        const angle = Math.random() * Math.PI * 2;
        const radius = 300 + Math.random() * 1200; 
        const x = Math.cos(angle) * radius;
        const y = Math.sin(angle) * radius;
        const z = -Math.random() * 12000 - 800; 
        
        img.dataset.origX = x; img.dataset.origY = y; img.dataset.origZ = z;
        gallery.appendChild(img);
    });
}

function startAnimationLoop() {
    const photosAndTitle = document.querySelectorAll('.intro-photo, .intro-title-content');
    const bgContainer = document.getElementById('bgImageContainer');
    
    const TIMELINE_DEPTH = 4000; 
    const MAX_DEPTH = state.WARP_DEPTH + TIMELINE_DEPTH;

    function animate() {
        if (!state.countryFocused && !state.eventFocused && !state.animatingReturn) {
            state.scrollDepth += state.velocity;
            state.velocity *= 0.85; 
            
            if (state.scrollDepth < 0) { state.scrollDepth = 0; state.velocity = 0; }
            if (state.scrollDepth > MAX_DEPTH) { state.scrollDepth = MAX_DEPTH; state.velocity = 0; }
            
            if (state.scrollDepth > 0 && state.scrollDepth < 50 && Math.abs(state.velocity) < 1) {
                state.scrollDepth = 0;
                state.velocity = 0;
            }

            if (state.scrollDepth <= state.WARP_DEPTH) {
                // --- Phase 1: 飛梭模式 ---
                dom.bgContainer.style.pointerEvents = "none"; 

                let warpProgress = state.scrollDepth / state.WARP_DEPTH;
                let mapScale = 0.05 + (0.95 * Math.pow(warpProgress, 4)); 
                bgContainer.style.opacity = Math.min(1, warpProgress * 2.5); 
                
                if(dom.svg) {
                    const winW = window.innerWidth, winH = window.innerHeight, vb = dom.svg.viewBox.baseVal;
                    const vbW = vb.width || 2000, vbH = vb.height || 1200;
                    const getCoverSize = (fW, fH) => { const sR = vbW / vbH, fR = fW / fH; return (sR < fR) ? {w: fW, h: fW/sR} : {h: fH, w: fH*sR}; };
                    
                    const s0 = getCoverSize(winW, winH);
                    dom.svg.style.width = `${s0.w}px`; dom.svg.style.height = `${s0.h}px`;
                    
                    // 重置使用者的手動操作
                    state.baseTranslateX = (winW - s0.w)/2;
                    state.baseTranslateY = (winH - s0.h)/2;
                    state.userScale = 1;
                    state.userPanX = 0;
                    state.userPanY = 0;
                    dom.svg.style.transform = `translate(${state.baseTranslateX}px, ${state.baseTranslateY}px) scale(${mapScale})`;
                }

                photosAndTitle.forEach(el => {
                    const oz = el.dataset.origZ ? parseFloat(el.dataset.origZ) : 0;
                    const ox = el.dataset.origX ? parseFloat(el.dataset.origX) : 0;
                    const oy = el.dataset.origY ? parseFloat(el.dataset.origY) : 0;
                    const currentZ = oz + state.scrollDepth;
                    
                    let op = 1.0; 
                    if (currentZ > 100) op = 1.0 - ((currentZ - 100) / 600); 
                    
                    if (currentZ > 800 || op <= 0) {
                        el.style.opacity = 0;
                    } else {
                        el.style.opacity = op;
                    }
                    el.style.transform = `translate(-50%, -50%) translate3d(${ox}px, ${oy}px, ${currentZ}px)`;
                });

                state.progress = 0;
                if (state.isMobile) {
                    dom.leftPanel.style.opacity = 0;
                    dom.leftPanel.classList.remove('mobile-active');
                } else {
                    dom.leftPanel.style.left = `-33.33%`; dom.leftPanel.style.opacity = 0;
                }
                
                dom.warpMask.style.opacity = 0.7 - (warpProgress * 0.5);
                updateAllMarkers();

            } else {
                // --- Phase 2: 地圖右移與 Timeline ---
                dom.bgContainer.style.pointerEvents = "auto"; 
                bgContainer.style.opacity = 1;
                
                state.progress = (state.scrollDepth - state.WARP_DEPTH) / TIMELINE_DEPTH;
                const panelPhase = Math.min(Math.max((state.progress) / 1, 0), 1);
                
                if (state.isMobile) {
                    dom.leftPanel.style.opacity = panelPhase;
                    if (panelPhase > 0.1) dom.leftPanel.classList.add('mobile-active');
                    else dom.leftPanel.classList.remove('mobile-active');
                } else {
                    dom.leftPanel.style.left = `${-33.33 + 33.33 * panelPhase}%`;
                    dom.leftPanel.style.opacity = panelPhase;
                }
                
                dom.warpMask.style.opacity = 0.2 - (panelPhase * 0.2); 
                if(dom.svg) updateSVGTransform(); 
            }
        }
        requestAnimationFrame(animate);
    }
    animate();
}

function init() {
    Object.entries(DATA.markers).forEach(([countryCode, cityList]) => {
        cityList.forEach(city => { city.country = countryCode; });
    });

    const onWheel = e => { 
        const isInsidePanel = e.target.closest('#leftPanel');
        if (isInsidePanel && state.scrollDepth >= state.WARP_DEPTH) {
            if (state.isMobile) {
                if (e.deltaY > 0 || (e.deltaY < 0 && dom.scrollArea.scrollLeft > 0)) {
                    dom.scrollArea.scrollLeft += e.deltaY;
                    e.preventDefault(); 
                    return;
                }
            } else {
                if (dom.scrollArea.scrollTop > 0 && e.deltaY < 0) return; 
            }
        }
        let speedMultiplier = 1;
        if (state.scrollDepth <= state.WARP_DEPTH) {
            let progress = Math.max(0, state.scrollDepth / state.WARP_DEPTH);
            speedMultiplier = 1 + Math.pow(progress, 3) * 4.5; 
        }
        state.velocity += e.deltaY * 0.8 * speedMultiplier; 
    };
    
    window.addEventListener('wheel', onWheel, { passive: false }); 
    
    // ==========================================
    // 【手動 Pinch-to-Zoom 核心邏輯】
    // ==========================================
    let pinchState = { active: false, initialDist: 0, initialScale: 1, lastX: 0, lastY: 0, panActive: false };

    dom.bgContainer.addEventListener('touchstart', e => {
        if (state.scrollDepth <= state.WARP_DEPTH) return;
        state.mapDragThreshold = false; // 每次觸控重置拖曳狀態
        
        if (e.touches.length === 2) {
            pinchState.active = true;
            pinchState.panActive = false;
            const dx = e.touches[0].clientX - e.touches[1].clientX;
            const dy = e.touches[0].clientY - e.touches[1].clientY;
            pinchState.initialDist = Math.hypot(dx, dy);
            pinchState.initialScale = state.userScale;
            e.preventDefault(); 
        } else if (e.touches.length === 1 && state.userScale > 1) {
            pinchState.panActive = true;
            pinchState.active = false;
            pinchState.lastX = e.touches[0].clientX;
            pinchState.lastY = e.touches[0].clientY;
        }
    }, { passive: false });

    dom.bgContainer.addEventListener('touchmove', e => {
        if (state.scrollDepth <= state.WARP_DEPTH) return;
        if (e.target.closest('#leftPanel') || e.target.closest('#infoBox')) return; // 在選單上滑動時不縮放

        if (pinchState.active && e.touches.length === 2) {
            state.mapDragThreshold = true;
            const dx = e.touches[0].clientX - e.touches[1].clientX;
            const dy = e.touches[0].clientY - e.touches[1].clientY;
            const dist = Math.hypot(dx, dy);
            
            let newScale = pinchState.initialScale * (dist / pinchState.initialDist);
            if (newScale < 1) newScale = 1; // 限制不能縮得比原本還小
            if (newScale > 4) newScale = 4; // 最大放大 4 倍
            
            state.userScale = newScale;
            applyTransform();
            e.preventDefault();
        } else if (pinchState.panActive && e.touches.length === 1) {
            const dx = e.touches[0].clientX - pinchState.lastX;
            const dy = e.touches[0].clientY - pinchState.lastY;
            
            if (Math.abs(dx) > 3 || Math.abs(dy) > 3) state.mapDragThreshold = true;
            
            state.userPanX += dx;
            state.userPanY += dy;
            
            pinchState.lastX = e.touches[0].clientX;
            pinchState.lastY = e.touches[0].clientY;
            
            applyTransform();
            e.preventDefault();
        }
    }, { passive: false });

    dom.bgContainer.addEventListener('touchend', e => {
        if (e.touches.length < 2) pinchState.active = false;
        if (e.touches.length === 0) pinchState.panActive = false;
        else if (e.touches.length === 1 && state.userScale > 1) {
            pinchState.panActive = true;
            pinchState.lastX = e.touches[0].clientX;
            pinchState.lastY = e.touches[0].clientY;
        }
    }, { passive: false });
    // ==========================================

    setupIntroGallery();

    dom.scrollArea.addEventListener('scroll', () => {
        updateTimelineFade();
        const el = dom.scrollArea;
        if (!state.countryFocused && !state.eventFocused) {
            const dist = state.isMobile 
                ? el.scrollWidth - Math.ceil(el.scrollLeft) - el.clientWidth 
                : el.scrollHeight - Math.ceil(el.scrollTop) - el.clientHeight;
                
            dom.overlayBottom.style.transform = dist <= 15 ? 'translateY(0)' : 'translateY(100%)';
        } else { 
            dom.overlayBottom.style.transform = 'translateY(100%)'; 
        }
    });

    dom.backBtn.addEventListener('click', returnFromCountryFocus); 
    dom.eventBackBtn.addEventListener('click', returnFromEvent);
    window.addEventListener('click', (e) => { if (!e.target.closest('.rightPoint') && !e.target.closest('.timeline-event')) clearHighlighting(); });
    
    dom.markers.forEach((el, id) => {
        el.addEventListener('mouseenter', (e) => { 
             e.stopPropagation(); 
             if (state.eventFocused) { clearHighlighting(); highlightMarkerAndTimeline(id); }
             const data = findMarkerBaseData(id); updateCityTooltip(data ? data.city : (el.dataset.label || "City"), el); 
        });
        el.addEventListener('mouseleave', () => { updateCityTooltip(null); if (state.eventFocused) clearHighlighting(); });
        el.addEventListener('click', (e) => { e.stopPropagation(); dom.cityLabel.style.opacity = 0; showRichInfo(id); });
        
        el.addEventListener('touchend', (e) => {
            if (state.mapDragThreshold) return; // 如果是拖曳中，忽略點擊事件
            e.stopPropagation();
            dom.cityLabel.style.opacity = 0; showRichInfo(id);
        });
    });
    
    buildTimeline(); 
    initMap(); 
}

window.addEventListener('load', init);
window.addEventListener('resize', () => { 
    state.isMobile = window.innerWidth <= 768; 
    buildTimeline();
    if(!state.countryFocused && !state.eventFocused) updateSVGTransform(); 
});
</script>
</body>
</html>